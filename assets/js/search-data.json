{
  
    
        "post0": {
            "title": "Smart Contract Development - Best Practices",
            "content": "General Contract Development Guidelines (Best Practices) . Smart contract programming requires a different engineering mindset than what you may be used to. . The cost of failure is high and changes can be difficult, making it in some ways similar to hardware programming or financial services programming rather than web or mobile app development. . It is therefore not enough to defend against known vulnerabilities. Instead you will need to learn a new philosophy of development. . Prepare for Failure . Place circuit breakers | Manage money at risk (rate limiting, maximum usage,etc) | Effective mechanism for proxy upgrades | . Stay up to Date . Check your contracts for any new bug as soon as it is discovered | Keep on upgrading all tools and libraries | Adopt new security techniques that emerge (and seem useful) | . Keep it simple . Keep contract logic simple. Modularize code. Use already written code, use as many lego blocks as you can, before writing custom logic | Clarity over performance (Debatable) For example one could argue that the OpenSea Seaport contract is so damned performant that it affects the auditability of the contracts. But realise the fact that the Seaport contract will be deployed on the Ethereum mainnet and will be used to mint hundereds of thousands of NFTs, saving the users millions of dollars over the course of time. . So, based on the nature of your contract, do have healthy, sane discussions on whether you will place more impetus on performance or clarity. . | Roll out in phases. Have a bug bounty in place, test your code-base thoroughly and immediately add relevant tests to your codebase as soon as a new attack is discovered. | . Blockchain Properties . Randomness can be gamified. | Timestamps are imprecise. Miners can influence the time of execution of a txn within a margin of several seconds | Beware of external calls. Private data is not actually private and public functions can be called by anyone in any order. | Prefer reusing contract code only when you have proven previously-deployed contracts which you own. Otherwise go for duplication of code. Efforts such as OpenZeppelin‚Äôs Solidity Library seek to provide patterns such that secure code can be re-used without duplication . | . Development best practices: . External calls are very risky. Try and avoid doing that, prefer duplicating code over using a call to an external contract. | And when you absolutely have to do that, make sure that the contract is owned/maintained/managed by a trusted party. | Always mark your function making external calls as unsafe via comments and naming convention | Avoid making state changes after the external call. The usual re-entrancy attack and following the check-effects-interactions pattern circus. | . | | .",
            "url": "https://saxenism.com/markdown/smart-contract/solidity/security/development/best-practices/2022/08/28/General-Contract-Development-Guidelines.html",
            "relUrl": "/markdown/smart-contract/solidity/security/development/best-practices/2022/08/28/General-Contract-Development-Guidelines.html",
            "date": " ‚Ä¢ Aug 28, 2022"
        }
        
    
  
    
        ,"post1": {
            "title": "DeFi TITS - A Primer on Testing",
            "content": "The International Testing Standard (TITS) for DeFi . DeFi Testing is broken. Doesn&#39;t matter how many auditors had a stab at your protocol, if you haven&#39;t sufficiently tested your protocol, you are basically gambling with your user&#39;s funds. Creating a repo to publicly critique the quality of the test suite of major DeFi protocols. . &mdash; Rahul Saxena ü¶Äü¶Ä (@saxenism) July 27, 2022 Mission Statement . I believe that protocols need to be held to a higher standard of testing. Web3 protocols are decentralised, therefore there are no centralised authorities, and subsequently there is no regulatory pressure on the protocols to do quality checks on their protocols. . Is this an issue? YES Is this a big issue?YES . Why? . Well, because, speaking strictly from an economic perspective, it makes much more sense for a protocol to use its time and developer resources on shipping a v2 of their protocol once the initial set of smart contracts are coded rather than spending it on testing their protocol. The protocols presently, try to, conviniently shift the burden of testing and quality assurance on the auditing firms and sometimes on insurance firms. However, Auditing + Insurance is still not enough to offer the level of peace of mind that people should have on software that handles their money. . Therefore, the development team, that is the most intimately familar with the code base, must make it a sacred duty of theirs (just like doctors take the Hippocratic Oath) to test their code to the best of knowledge and ability. . All in all, these softwares (DeFi protocols) handle the hard earned money of everyday Joes like you and me (and also money of stupid funds like 3AC, but yeah, you get the point) so, we cannot let the protocols continue with lax testing, because not everything can and should be viewed with an economic lens, somethings should exist simply because of personal or community ethics. . It does not matter (much) how many auditors have had a stab at your protocol, you, as a developer, do not really understand if your protocol really works and is robust enough to take on the uncertainities of the real world if you have not tested your protocol thoroughly. . Therefore, with this repository, I aim to create a certain set of testing standards that all DeFi protocols should strive to meet. . I plan to create this set of standards via iterations. Iterations of publicly critiquing leading DeFi protocols that are in use today, so that the up and coming protocols in the same space can get an idea and inspiration for the level of testing that the entire community expects out of a protocol that claims to handle money. . List of protocols being evaluated . Maple Finance | Random tid bits about traditional testing that I have picked up‚Ä¶ . This is definitely not molded for web3 yet, but consider this a good starting point if you haven‚Äôt formally studied Software Engineering. . Testing of software is an extremely imaginative and cognitively demanding task, more so in DeFi. So let your imagination go wild and gather ideas regarding testing from any walk of life, science, religion, parenting, social sciences, etc. Just about everything is fair game in testing. . 1. Old wisdom related to testing . 1.1 Presence of bugs . Testing can esure that defects are present but it cannot prove that a particular software is bug-free. Which isn‚Äôt something super nice, but I‚Äôm coping too. . 1.2 None can do exhaustive testing . Your software can never be tested for every imaginable and possible test cases. Trust me fellow crypto bro, you cannot. . 1.3 Test Early . Earlier you test, lesser you‚Äôll cry. . 1.4 Defect Clustering . Pareto principle but for origin of software bugs. . 1.5 Pesticide Paradox . Don‚Äôt be an idiot and test the same thing over and over with different methods. Find novel ways to screw with your protocol. . 1.6 Testing is context-dependent . Every protocol does something special. Test the shit out of that. . 1.7 Absence of errors fallacy . Just like your hot and caring girlfriend, a 100% bug-free software exists only in your imagination. . 1. Why testing is important . Saves you and your users from getting rekt. | Hoping for your protocol‚Äôs success without adequate testing is like going into a gunfight without a bulletproof vest and hoping you don‚Äôt get shot. | Time and effort spent on testing can be leveraged to get better terms when you get your protocol insured. | In short, you‚Äôll get your lambo only wen you test. | . Thank you for coming to my TED talk. Bye. . Types of testing . Functional and Non Functional . Non Function includes . Testing the Documentation (which includes) Instructions | Examples | Messages | Samples | . | Installation Testing | Performance Testing Load Testing | Spike Testing | Stress Testing | Endurance Testing | . | Reliability Testing Feature Testing | Regression testing | Load Test | Objectives Testing | . | Security Testing (web2 stuff) Access to application | Data Protection | Brute FOrce | SQL Injection | Service Point | Session Management | Error Handling | Specific Risky Functionalities | . | . 2. SDLC . Requirement | Analysis (outcome from this phase is SRS) | Design (HLD and LLD) | Coding | Testing | Deployment and all | . 2.1 Waterfall Model . Sequential design process. One way street, so back tracking is not possible. . . 2.2 Spiral Model . Combination of iterative development process model and sequential linear development model. . . 3. Validation vs Verification . Verification Validation . Methods involve: review, inspection, unit testing &amp; integration testing | Involves testing the entire system (system testing) | . Usually done by developers while developing | Usually done by tester and after developing of the product by developers | . Concerned with the phase containment of errors | Concerned with making the final product error free | . Involves static and dynamic analysis of code | Involves only dynamic analysis of code | . 4. Types of software testing . 4.1 Unit Testing . Can be done in the development phase itself. Unit means a particularly small piece of (preferrably independent) code such as a function, small module etc. . Smallest element of the software is a unit and testing each of those units is unit testing. . 4.2 Integration Testing . Combine different units of code and test whether they work together as expected to produce the desired output or not. . 4 common integration testing startegies are as follows: . 4.2.1 Big Bang Testing . All units are linked at once, resulting in a complete system. Here, it is difficult to isolate any errors found. . 4.2.2 Top Down . Higher level modules are tested first after which the lower level modules are tested. Higher level modules refer to the main modules and lower level refers to the sub modules. . Stubs (temporary modules) are used to simulate the behaviour of the lower-level modules that are not yet integrated. . Used when software needs to interact with an external system. . 4.2.3 Bottom Up . Lower level modules are tested first and then the higher level modules. . This approach uses test drivers which are mainly used to initiate and pass the required data to the sub modules, implying we pass mock data that should ideally have come from (the not yet implemented) higher modules. . 4.2.4 Mixed (Sandwiched integration testing) . A mixed integration testing follows a combination of top down and bottom-up testing approaches. . 4.3 System Testing or End-to-End Testing . Testing the entire system. Here, we navigate all the necessary modules of an application and check if the end features or the end business works fine, and test the product as a whole system. . 4.3.1.1 Alpha Testing . The testers are people who have built the product. | Done before releasing the product. | Involves both white box and black box testing | . 4.3.1.2 Beta Testing . Beta testing is performed by a select set of clients who are not part of the organization. | User input on the product is collected to ensure the product is ready for real time users | Commonly involves only black box testing | . 4.3.2 Acceptance Testing . It is a formal testing according to user needs, requirements and business processes conducted to determine whether a system satisfies the acceptance criteria or not and to enable the users, customers or other authorized entities to determine whether to accept the system or not. . Smoke Testing or Build Verification Testing . Subset of acceptance testing | . Smoke Testing Sanity Testing . Smoke testing is done to assure that the acute functionalities of program is working fine. | Sanity testing is done to check the bugs have been fixed after the build. | . Smoke testing is documented. | Sanity testing isn‚Äôt documented. | . Smoke testing is done to measures the stability of the system/product by performing testing. | Sanity testing is done to measures the rationality of the system/product by performing testing. | . Smoke testing can be performed either manually or by using automation tools. | Sanity testing is commonly executed manually, not by using any automation approach. | . Smoke testing is used to test all over function of the system/product. | Sanity testing is used in the case of only modified or defect functions of system/products. | . Smoke testing is performed when new product is built. | Sanity testing is conducted after the completion of regression testing. | . 4.3.3 Mutation Testing . Type of white box testing | Extremely costly and time consuming but also extremely efficient in finding errors and ambiguities | In this type of testing, you slightly change the value/logic/statements in your code and see if you get the expected output in your tests | . 4.3.4 Performance / Non functional Testing . Non-functional testing is defined as a type of software testing to check non-functional aspects of a software application. It is designed to test the readiness of a system as per nonfunctional parameters which are never addressed by functional testing. . This testing tests the following things (among others): . Volume | Load | Stress | Security | Configuration | Compatibility (BrowserStack :P) | Recovery | Installation etc | . 4.3.5 Recovery Testing in Software Testing . Recovery testing is a type of system testing which aims at testing whether a system can recover from failures or not. | To ensure that a system is fault-tolerant and can recover well from failures, recovery testing is important to perform. | . 4.4 Regression Testing . Regression testing is the process of testing the modified parts of the code and the parts that might get affected due to the modification to ensure that no new errors have been introduced in the software after the modifications have been made. . 4.4.1 Techniques for the selection of test cases for regression testing . Select all test cases (Most thorough but inefficient approach) | Select test cases randomly (Dangerous approach) | Select modification traversing test cases (Huge upfront work required to identify these test cases) | Select higher priority test cases (Assign priority values to all your tests, then re-test all your highest priority tests) | . 4.4.2 Sanity Testing . Subset if regression testing | Done to ensure that the code changes that have been made are working properly or not | Focus of the team during sanity testing is to validate the functionality of the application and not detailed testing | Usually performed on builds where the production deployment is required immediately like a critical bug fix. | Performed only after the software product has passed the smoke test and the QA team has accepted for further testing | . 5. STLC (Software Testing Life Cycle) . Requirement Analysis (Truly truly understand what your protocol is supposed to do) | Test Planning / Strategy Phase (Based on the context of the protocol in question, zero in on a testing strategy) | Test Case Development (This should take the maximum amout of time. List down all test cases that you think are appropriate.) | Environment Setup (Independent of other stages) (Don‚Äôt tell me you don‚Äôt already have Forge installed) | Test Execution (Code up all the test cases you came up with earlier. You can do back and forth between Test Execution and Case Development phase, but try to keep it minimal) | Test Cycle Closure (Create a good report. Remember, chads keep their work presentable) | . 6. Non Functional Testing . This is based on customer expectations as opposed to functional testing which is based on customer requirements. | Non functional testing describes how the product works rather that what the product does | Includes things like performance testing, scalability, volume testing, load testing, stress testing etc. | . 6.1 Performace Testing . Ensures software application will perform well under their expected workload | Goal is not to find bugs but to elimiate performance bottle-necks | Provides accurate information about the speed, scalability and stability of the software | Types of performance testing types Load Testing (Multiple users access application simultaneously) | Stress Testing | Endurance Testing | Spiking Testing | Volume &amp; Scalability Testing | . | Pay attention to: Long load time | Poor response time | Poor scalability | Bottlenecking | . | Examples of performance Test cases: Verify response time is not more than 4 seconds when 1000 users access the website simultaneously | Check the maximum number of users that the application can handle before it crashes | Verify response time of the application under low, normal, moderate and heavy load conditions | . | . 6.2 Cross browser Tests and Mobile Testing and API Testing . See if this is applicable and test if you have the resources to do so. . Types of API Testing . Functionality Testing | Reliability Testing | Load Testing | UI/UX Testing | Interoperability Testing | Security Testing | Penetration Testing | Negative Testing | . 7. Agile Testing (Test Driven Development (TDD)) . Testing is continuous | Continuous Feedback | Decreased time of feedback response | Less documentation | Test Drive | Simplified Code | . . 7. Software Testing Documentation . 7.1 Test Plan . Provides the outline strategy which will be implemented for testing the application and also the resources that will be required. Test environement will also be described. . Make sure that you also set up a defect/bug life cycle . 7.2 Test Scenario . Notifies the area in which your application will experiment . 7.3 Test Case . Collected steps and conditions with inputs that can be implemented at the time of testing. . 7.4 Traceability Matrix . A table where you can relate test case IDs with protocol requirement IDs. . 8. Defect Management Process (What to do when you find bugs) . Detect the defect | Formulate the bug report | Fix bug | Bug list creation (so that, yk, history doesn‚Äôt repeat itself and everyone sees that you have 3 brain cells) | . It is important to note in the first two points, whenever you encounter a bug, you have to reach to the root cause of the bug and report that. Because, it is very much possible that the actual coding error that caused the bug might create many more bugs in the future. . In short, treat the root cause and not just the symptoms. . 9. When to choose manual testing . 9.1 Exploratory Testing . Carried out by domain experts. Minimal planning . 9.2 Usability Testing . User friendliness of an app . 9.3 Ad Hoc Testing . Informal testing. No documents are followed. . 9.4 How to do manual testing . Understand the requirements | Write the test cases | Conducting the tests | Log Good Bug Reports | Report the results (Detailed test report) | What to automate? . Repetitive Task | Capturing Results | Data Entry Tasks | Timing or Screening Responsiveness | Non functional Testing | Environment Setup/Tear down | . Approaches to Test Automation (Look them up) . Code driven Testing | Graphical User Interface | Framework Approach Linear Scripting framework | Data driven framework | Keyword driven framework | Modular testing framework | Hybrid Testing Framework | . | .",
            "url": "https://saxenism.com/defi/testing/web3/forge/defi-tits/2022/08/28/A-Primer-To-Testing.html",
            "relUrl": "/defi/testing/web3/forge/defi-tits/2022/08/28/A-Primer-To-Testing.html",
            "date": " ‚Ä¢ Aug 28, 2022"
        }
        
    
  
    
        ,"post2": {
            "title": "Maple Finance - An overview",
            "content": "Maple Finance: A brief overview . To get a detailed idea about Maple visit: . Maple Official Wiki . Brief Overview: Maple Finance . Decentralised corporate credit market protocol. Note This is a decentralised protocol but not trustless, since we always HAVE to assume Pool Delegates to be fair and non-malicious actors . | Borrowers can leverage their reputations to get undercollateralized loans over time. They do so by getting access to capital pools of different Pool Delegates after liaisoning with them. . | Interest Compounds: Interest is accrued and reinvested to enable capital to compound over time . | Pool Delegates carry out the entire due diligence. Lenders chill out. LPs (Lenders) earn revenue by claiming interest generated by the pool. . | Pool Delegates use Maple to attract funds, crack good deals with blue chip borrowers and then earn good performance fee. But they have to stake a good amount of MPL-USDC 50-50 BPTs (Balancer Pool Tokens) so that their incentives are aligned with the LPs. . | After agreeing on terms with a borrower, one or more Pool Delegates will fund the loan with funds available in their pools. . | Stakers are MPL holders and deposit BPT as first loss reserve against loan defaults. BPTs are burned to cover the shortfall after liquiditing the collateral of a borrower. . | Concept of ideal collateral ratio, grace period, late fee and liquidation post grace period exists. . | Governor is a multi-sig wallet that controls the administrative functions in the protocol (admin) . | Contract Instance Admins or local admins are admins for a particular task. Eg. These admins are set by: Governor in case of factories | Pool Delegate in case of a Pool | Borrower in case of a loan | . | Protocol Admin/Global Admin: Can call only one function, that pauses every outward facing function of the protocol. Called only when things have got really bad. | Maple Protocol Architecture . The architecture is pretty straightforward. Doesn‚Äôt need much explaining. . There is a Pool Factory, which will create Pools, which will be managed by Pool Delegates. Simple. Each pool will have a Liquidity Locker (created from its factory) to store the pool‚Äôs liquidity | Each pool will have a Debt Locker (created from its factory) to store the debt that is given out from that particular pool | Each pool will have a Stake Locker (created from its factory) for the Pool Delegate to stake their MPL-USDC BPT tokens. This is where the stakers would also stake their tokens. | Each pool will generate some MPL rewards as a result of this staking and will be distributed among the LPs. | . | Similarly there is a Loan factory, which will be used by Borrowers to create Loan requests(contracts). Simple Each loan will have a Collateral Locker (created from its factory) to store the borrower‚Äôs collateral | Each loan will have a Funding Locker (created from its factory) which I am not sure why it exists. Probably to store the repaid amount? IDK | . | Ofcourse Chainlink oracles are being used to fetch prices and execute functions dependent on price action. | . Security Considerations: . Pool Delegates are supposed to be trusted actors. Can‚Äôt really do anything if they turn out to be malicious. | dapp.tools (HEVM) has been used for extensive unit testing + fuzzing If you know anything James Bach, you‚Äôll know that he‚Äôll call this checking rather than actual testing. And this is what basically interests us here. . | External code audits by Deduab, PeckShield, TrailOfBits, Code4rena. | 2 week internal audit by the Maple team This kind of audit is often susceptible to developer biases. But it is complimented by external audits here‚Ä¶ So, shouldn‚Äôt be much of an issue. Anyway, we are still more interested in testing rather than the auditing and the plethora of audit reports of Maple. . | OZ Defender is in use to inform of any emergencies. | Incase of a oracle outage, all transactions requesting asset prices will be reverted. Manual override possible. Hmm interesting claim. Will be fun to check this. . | Incase of emergencies, contract instance admins (local admins) and/or protocol admins/global admins will come into play. | Smart contract logic that is deployed on the mainnet cannot be altered in any way. Fuck proxies. This is good. Significantly reduces the surface area of possible attacks. . | Understanding Pools . If as a LP or staker you want to withdraw your funds, you‚Äôll first have to trigger a cooldown function and wait for it get over before you can withdraw your funds or even cancel your staking as a staker. . In the following image it is not depicted properly, but the Pool Delegate also has to stake a shit ton of BPTs to be whitelisted as a Pool Delegate by the MapleDAO in the first place. . . Understanding Loans . The Loan contracts are created by Borrowers out of the LoanFactory contracts, which are whitelisted in MapleGlobals to ensure that only certain types of Loan contracts are used in the protocol. . | Loan contracts are used to: Set terms such as: | . APR, Payment Interval Length, Term Lenght, Collateral Ratio, Collateral and Borrow asset, etc. + Receiving capital from lenders + Withdrawing the loan + Interest Payments + Liquidating Collaterals | . | Important point to note is the use of Payment Calculators. These are used to calculate interest payments, late fees, premium fees etc. These are also whitelisted in the MapleGlobals to ensure no malicious payment calculators are used. | At first glance this looks like a whitelisted library which will be used for calculations based on the specifications of the loans, such as simple/compound interest. This also means that no calculation would be happening inside of the Loan contract . Need to check if these calculation libraries can somehow be tampered with. . A Loan can be funded by any number of pools, but those pools must be instantiated from PoolFactory contract itself. The LPs get LoanFDTs. | LoanFDTs are similar to LP Tokens as they represent a claim over a part of principal plus any proportional interest that gets generated. . LoanFDTs that Maple is using isn‚Äôt the same old ERC20, they are using a relatively unknown ERC2222 standard. Need to check that thoroughly then. . Borrowers can drawdown any amount that is both above the request Loan amount, and below the current balance of the FundingLocker. | The question here is, why would Maple allow lenders to deposit funds in the Loan contract past their requested amount? Wouldn‚Äôt that essentially be wasted amount? . At the time of the drawdown: a percentage of the drawdown amount is paid to the MapleTreasury from the FundingLocker as the treasury fee. | investor fee is paid to the lenders (a % of the drawdown amount). Sent from FundingLocker to the Loan to be claimed by the lenders. Seems a bit off. Investigate again. . | Drawdown minus fee is transferred to the Borrower | . | Excess funds are sent to Loan contract to be claimed by the lenders. . | Normally, interest is paid in constant amounts at regular intervals, and principal is returned on last repayment. Otherwise, you can also pay the entire remaining balance of the loan in one transaction including principal and the amount the interest that should be paid (we use a function called PremiumCalc here). . | Liquidations work as usual apart from the fact that you can only call it as a pool delegate if your equity in the loan is more than the minLoanEquity | This again will be interesting to test. Should already be heavily testsed. . Another (unnatural) thing that Maple is doing in the Liquidation is that, post the calling of liquidation, they are taking the collateral from the CollateralLocker and converting it into the Borrow Asset using Uniswap and then transferring it to be to the Loan contract for being claimed by the lenders. | I don‚Äôt understand why didn‚Äôt Maple just let the lenders claim their share of the collateral in terms of collateral asset itself. Perhaps it has got to do something with the LoanFDT which is an ERC2222 instead of pure ERC20. Need to get more clarity here. . Understanding MPL Token . MPL token is the native token of Maple Protocol and it inherits: ERC20 for standard token behavior | ERC2222 for profit distribution of USDC from the Maple Treasury | . | Interestingly, the MPL token repo has only been audited by Peckshield. So, this token particularly must have stringent testing. . Also, what‚Äôs more interesting is that the scope of Peckshield‚Äôs audit is just ERC20-compliance of the Maple token . So, everyone already knows what ERC20 is, so let‚Äôs skip it. But what‚Äôs interesting‚Ä¶is the use of ERC2222 standard, which adds the functionality to represent claims on any type of crypto cash flow on top of ERC20 functionalities. Think of it like this standard enables dividend like payouts in crypto where token holders are treated akin to share holders and all withdrawals which is based on the proportion of the withdrawing party‚Äôs MPL holdings is taken care of, by ERC2222. . MPL token is used in the 50-50 MPL-USDC Balancer pool created during the protocol deployment and will be used in all other Balancer pools which will have BPTs used in StakeLockers. . | The MPL token recieves fee periodically from the Treasury (at the discretion of the Governor). Basically funds are gathered in the Maple Treasury from all kinds of protocol fee, converted to USDC and sent to the MPL token contract. . | When MPL tokens are added as liquidity to the Balancer Pool, the Balancer pool is the owner of those tokens, which are accruing USDC interest (from the Maple treasury, read point 3). To account for this, the FDT (MPL token contract) has an additional function called withdrawFundsOnBehalf which allows for the following: Claims USDC interest from MPL contract, transferring it into the Balancer pool contract address | The USDC supply increases and the MPL supply stays constant, increasing the implied value of MPL (since the buy pressure on MPL has increased) | . | Why did the buy pressure on MPL increase when the quantity of USDC increased in the MPL-USDC 50-50 balancer pool? . Well, because according to the constraints of the pool the quantity of both MPL and USDC must remain equal (50-50), and when the quantity of USDC is increased in the pool, the traders are incentivized to take out the excess USDC by supplying MPL. And to supply this MPL, they‚Äôll have to buy it from some DEX/CEX. . Understanding Pool Cover . Simple Concept. Lender funds need to be protected in case of a loan default | This protection(cover) is provided by volunteers. How can they do this? | Well, first they have to add liquidity to the MPL-USDC 50-50 Balancer Pool and get Balancer Pool Tokens (BPTs). Users can also directly buy these tokens. | Now every pool has a stakeLocker where these users can stake their BPT tokens and get StakeLockerFDTs in return. | Users use these StakeLockerFDTs to claim all future interest, since Pools reward the StakeLockers with a portion of the revenue generated in compensation for assuming more risk. | And at the time of liquidation, if these tokens are enough to compensate the lenders for the difference between the collateral required and pending repayments, then these users get the remaining BPTs, else, tata, bye bye. | . | The actual calculation of the minimum amount needed to compensate the lenders is a bit complicated (atleast looks complicated), since it requires you to be a little familiar with the Balancer protocol too. . Need to study, understand and potentially test this calculation. . Understanding Lockers . Dedicated smart contracts to hold custody assets. They‚Äôre kinda paranoid. I like this. Ok, no they are not paranoid. It‚Äôll be holding assets only in the v1. In later version it is supposed to all sorts of weird things. . | Lockers and what they hold: LiquidityLocker: asset used for liquidity for funding Loans | DebtLocker: Holds custody of LoanFDTs (to claim revenue and make liquidation calls) | StakeLocker: BPTs (used as a reserve to cover losses from defaulted Loans) | FundingLocker: Asset that will be borrowed during the funding period (pre-drawdown) | CollateralLocker: Collateral (against any loan) | . | In order for any new Locker strategy to be implemented, its corresponding Factory must be whitelisted in MapleGlobals using setValidSubFactory | Understanding Oracles . Chainlink oracles are used as price feeds. | An oracle wrapper contract acts as a safeguard against oracle downtime. I think a better solution would have been to have two oracle integrations (both Chainlink and Uni) so that if one fails, we always have the second one to fall back on. . | and yeah, even after those two, we could have had a oracle wrapper contract as a safeguard against orale downtime. . For USDC prices, a constant USD oracle will be deployed, with a constant price of 1 * 10 ** 8. Note that USDC has 6 decimals only but Chainlink price feeds use 8 decimals of precision | Planning for a zombie apocalype: Oracle wrappers have the capability to provide a manual price in the event of an oracle outage, using the security multisig. In all other cases, it will simply pass through the value from getLatestPrice in the Chainlink oracle. | . | ERC 2222 Working Mechanism: Example . Would be really cool and prolly helpful, if you go through this example and actually understand it. . Normal functioning of FDTs . Link . Functioning of ExtendedFDTs . These FDTs are extending the functionality of FDT to include functionality to account for losses that must also be distributed for liquidity providers and staker. . For Pools, it happens in the case when a loan has defaulted, all the BPTs are burnt and still there is a deficit. . For Stakers(StakeLocker), it happens in the case when a loan has defaulted and any number of BPTs are burnt. . Formulae used for accounting for losses are the exact same as normal FDTs. Check them out. . Link . Handling custodial ownership using ERC2258 . Another awesome ERC that Maple brings to light is the ERC2258, which allows tokens to be custodied by an entity such that they cannot be transferred/redeemed for underlying liquidity, yet allow the rightful owner to retain all future benefits and all losses. . Example: It allows users to stake PoolFDTs in the MplRewards contract without changing their PoolFDT ERC-20 balance. This allows them to earn MPL rewards in the MplRewards contract, while simultaneously accruing interest earned by the Pool. This would not have been possible with the original SNX-fork of the liquidity mining contract, since in that implementation, all Pool interest would have been accrued to the MplRewards contract itself, since it would hold a balance of PoolFDTs . This of it like pledging your stonks to someone. . Need to test this a bit.. can we transfer funds after giving custody and so on‚Ä¶ . Invariant . This equation must always be satisfied: . liquidityLockerBal + principalOut = fdtTotalSupply + interestSum - poolLosses .",
            "url": "https://saxenism.com/web3/solidity/defi-tits/lending/protocol-deep-dive/maple/maple-finance/2022/08/02/maple-finance-rundown.html",
            "relUrl": "/web3/solidity/defi-tits/lending/protocol-deep-dive/maple/maple-finance/2022/08/02/maple-finance-rundown.html",
            "date": " ‚Ä¢ Aug 2, 2022"
        }
        
    
  
    
        ,"post3": {
            "title": "Solidity Contract Proxies",
            "content": "Migration or Social Yeet (CT Lingo) . You keep all your deployed contracts immutable and non-upgradable. So, when you actually need to modify your deployed contract‚Äôs logic or add some functionality, you have to deploy a new contract and ask the users to start making their calls to this newly deployed version of your protocol‚Äôs smart contract address. . This is the truest form of upgrading your contracts, without compromising on the trustless (no onlyAdmin functions) and decentralisation facets of web3. However, as is amply clear pulling this type of an upgrade isn‚Äôt really a breeze. . Proxies . Proxy Terminologies . The Implementation Contract Which has all our code of our protocol. When we upgrade, we launch a brand new implementation contract. | . | The Proxy Contract Which points to which implementation is the ‚Äúcorrect‚Äù one, and routes everyone‚Äôs function calls to that contract | . | The User The make calls to the proxy | . | The admin This is the user(or group of users/voters) who upgrade to new implementation contracts. | . | Storage Variables . The cool thing about proxies and delegate call is that all our storage variables are going to be stored in the proxy contract and not in the implementation contract. Therefore, when you deploy a new contract and your proxy starts pointing to this new contract, you don‚Äôt have to migrate the data from the old contract as it is already in the proxy contract. . Issues with proxies . 1. Storage Clashes . When we do delegateCall from the proxyContract, we do the logic of implementationContract inside the proxyContract. . In Solidity storage layout begins at position 0 and increments for each new state variable. A proxy contract and its delegate/logic contracts share the same storage layout! . Here is an example to illustrate the problem. ProxyA defines two state variables, facetA and owner . . contract ProxyA { address facetA; address owner; constructor() public { owner = msg.sender; facetA = 0x0b22380B7c423470979AC3eD7d3c07696773dEa1; } fallback() external payable { address facetAddress = facetA; assembly { ... code omitted for simplicity } } } . FacetA declares one state variable. . contract FacetA { address user; function getUser() external view returns(address) { return user; } function setUser(address newUser) external { user = newUser; } } . ProxyA delegates function calls to FacetA. The problem is that, when delegating, ProxyA and FacetA share the same storage layout. The state variable facetA is at position 0. And The state variable user is also at position 0. So if the setUser function is called it will set user and facetA to the newUser value, which is obviously not the intention, the intention just being to set user only. . So, basically, you can only ever append variables to your implementation contract and not really change or re-order the old ones. . Now,ideally if you called setValue using delegateCall from your proxy contract, it should set the value of differentValue but it sets the value . 2. Function Selector Clashes . Function Selector: A 4 byte hash of a function name and function signature that define a function. . Now it is possible that a function in the implementation contract has the same function selector as an admin function in the proxy contract. Think of a scenario where function getPrice in the implementationContract has the same Function Selector as function destroyProxy. Definitely would not be good. . For example, the following two functions have the exact same function selector . function collate_propagate_storage(bytes16) external{} function burn(uint256) external {} . Contract to verify this statement is as follows and also can be found on this link: https://gist.github.com/saxenism/02af4e7a7fdb42801157571a3dab2c05 . // SPDX-License-Identifier: MIT pragma solidity &gt;=0.7.0 &lt;0.9.0; contract ProxyExperimentation { function getFunctionSignature(string memory signature) internal pure returns (bytes4) { return bytes4(keccak256(bytes(signature))); } function checkFunctionSelectorSimilarity() external pure returns (bool) { bytes4 functionSelector1 = getFunctionSignature(&quot;collate_propagate_storage(bytes16)&quot;); bytes4 functionSelector2 = getFunctionSignature(&quot;burn(uint256)&quot;); bool success = (functionSelector1 == functionSelector2); return success; } function verifyOtherFunctionDisimilarity() external pure returns (bool) { bytes4 functionSelector1 = getFunctionSignature(&quot;collate_propagate_storage(bytes16)&quot;); bytes4 functionSelector2 = getFunctionSignature(&quot;burnn(uint256)&quot;); bool result = (functionSelector1 == functionSelector2); return result; } } . Proxy Patterns . 1. Transparent Proxy Pattern . In this pattern, the admin can call only call the admin functions in the proxy contract and the users can only call the functions in the implementation contract. Admin functions are the functions that govern the upgrades. . This way, as an admin or as a user you can‚Äôt mix up functions from different contracts with the same function selector and no problems should occur. As a side note, now the admin cannot participate in their own DeFi protocol :P . 2. Universal Upgradable Proxies . Admin Only functions are kept in the implementation contract itself, instead of the proxy. . The advantage here is, if that happens, and two functions have the same function selector, then the Solidity compiler will let us know. Also, since there is one less read that we have to do, we save on gas costs. . So, it is necessary here that you implement the upgradation functions in the implementation contract, because otherwise you would be stuck and we get back to the YEET method . 3. Diamond Pattern . Allows for multiple implementation contracts. Is probably the best method to implement upgradable contracts, since it allows you to make granular changes/upgrades, but it can get really complex. So to use this, you need to be really really good at smart contract development. .",
            "url": "https://saxenism.com/web3/solidity/security/proxy/upgradation/2022/04/30/All-About-Proxies.html",
            "relUrl": "/web3/solidity/security/proxy/upgradation/2022/04/30/All-About-Proxies.html",
            "date": " ‚Ä¢ Apr 30, 2022"
        }
        
    
  
    
        ,"post4": {
            "title": "Enums",
            "content": "What are enums in Solidity? . enums or members of enumerated lists, in Solidity work much like enums in any other language. For me, it is basically a tool to reduce the stress on my mental RAM while writing code or smart contracts. . Typical Use Case: . Suppose you want to give your user an option to choose his favorite squad among 9 available options. The available options would be: . Black Bull | Silver Eagle | Blue Rose | Golden Dawn | Green Mantis | Crimson Lion | Aqua Deer | Purple Orca | Coral Peacock | . Suppose you intend to use the variable favSquad to denote your user‚Äôs favorite Black Clover squad and use that variable in subsequent logic. . One option (particularly messy one) would be to allow users to enter strings that denote their favorite squads, but that would bring forth a whole new hell of matching proper cases (upper cases and lower cases), also someone could enter a string that is out of scope, like Spade Kingdom for example. . Another option would be to assign numbers to each squad (0-8) based on their index, most probably like a mapping. That would work, but you‚Äôll have to always remember which number represents which squad while coding, which would be pretty uncomfortable. . Hence, we pivot towards using enums. Enums restrict a variable to have one of only a few predefined values. The values in this enumerated list are called enums. With the use of enums it is possible to reduce the number of bugs in your code. This helps you to not make a mistake, to enter something out of the domain, while entering data and also improves the program readability. . For example, this is how we would use enums: . pragma solidity ^ 0.8.0; contract testEnums { enum CloverSquad { BlackBull, GoldenDawn, SilverEagle, BlueRose, CrimsonLion, GreenMantis, CoralPeacock, PurpleOrca, AquaDeer } CloverSquad favSquad; CloverSquad firstRankedSquad = CloverSquad.GoldenDawn; function getFirstRankedSquad() public view returns (CloverSquad) { return firstRandkedSquad; } } . Taking enum inputs and checking invalid inputs . A question that might arise in your minds (it did in mine too üòÖ) is how do we take enums as input from the user of our smart contract. We do this by typecasting the enums and checking if it is out of range or not. . Example: . // Yes, you can use your enums in mappings. mapping (address =&gt; CloverSquad) public playerSquad; function selectFavoriteSquad(uint userFavSquad) external { require(userFavSquad &lt;= uint(CloverSquads.AquaDeer), &quot;Choose from 0 to 8&quot;); playerSquad[msg.sender] = CloverSquad(userFavSquad); // Further Logic.... } . Further Reading . That is about everything that you will need to know about enums to be well on your way, but if you really want to get deeper into enums, I would suggest reading this incredibly detailed article on enums. . Thank you &amp; Godspeed. .",
            "url": "https://saxenism.com/web3/solidity/enums/beginner/2021/06/17/Enums-In-Solidity.html",
            "relUrl": "/web3/solidity/enums/beginner/2021/06/17/Enums-In-Solidity.html",
            "date": " ‚Ä¢ Jun 17, 2021"
        }
        
    
  
    
        ,"post5": {
            "title": "CryptoZombies - Lesson 5",
            "content": "Lesson 5: . Tokens on Ethereum: A token on Ethereum is basically just a smart contract that follows some common rules ‚Äî namely it implements a standard set of functions that all other token contracts share. The token standard that‚Äôs a much better fit for crypto-collectibles like CryptoZombies ‚Äî is called ERC721 tokens. ERC721 tokens are not interchangeable since each one is assumed to be unique, and are not divisible. You can only trade them in whole units, and each one has a unique ID. using a standard like ERC721 has the benefit that we don‚Äôt have to implement the auction or escrow logic within our contract that determines how players can trade / sell our zombies. If we conform to the spec, someone else could build an exchange platform for crypto-tradable ERC721 assets, and our ERC721 zombies would be usable on that platform. So there are clear benefits to using a token standard instead of rolling your own trading logic. . | The contract of ERC721 standard looks pretty much like an interface, waiting to be implemented: contract ERC721 { event Transfer(address indexed _from, address indexed _to, uint256 indexed _tokenId); event Approval(address indexed _owner, address indexed _approved, uint256 indexed _tokenId); function balanceOf(address _owner) external view returns (uint256); function ownerOf(uint256 _tokenId) external view returns (address); function transferFrom(address _from, address _to, uint256 _tokenId) external payable; function approve(address _approved, uint256 _tokenId) external payable; } . | In Solidity, we can inheirt from multiple contracts. . | To avoid overflows and underflows, we use the SafeMath library. A library is a special type of contract in Solidity. One of the things it is useful for is to attach functions to native data types. For example, with the SafeMath library, we‚Äôll use the syntax using SafeMath for uint256. The SafeMath library has 4 functions ‚Äî add, sub, mul, and div. And now we can access these functions from uint256 as follows: using SafeMath for uint256; uint256 a = 5; uint256 b = a.add(3); // 5 + 3 = 8 uint256 c = a.mul(2); // 5 * 2 = 10 . | assert is similar to require, where it will throw an error if false. The difference between assert and require is that require will refund the user the rest of their gas when a function fails, whereas assert will not. So most of the time you want to use require in your code; assert is typically used when something has gone horribly wrong with the code (like a uint overflow). . | The standard in the Solidity community is to use a format called natspec. | Also, thanks for Loom Network for bringing such awesome animations to us :D . . Solidity code from Lesson 5: . erc721.sol . pragma solidity &gt;=0.5.0 &lt;0.6.0; contract ERC721 { event Transfer(address indexed _from, address indexed _to, uint256 indexed _tokenId); event Approval(address indexed _owner, address indexed _approved, uint256 indexed _tokenId); function balanceOf(address _owner) external view returns (uint256); function ownerOf(uint256 _tokenId) external view returns (address); function transferFrom(address _from, address _to, uint256 _tokenId) external payable; function approve(address _approved, uint256 _tokenId) external payable; } . safemath.sol . pragma solidity &gt;=0.5.0 &lt;0.6.0; /** * @title SafeMath * @dev Math operations with safety checks that throw on error */ library SafeMath { /** * @dev Multiplies two numbers, throws on overflow. */ function mul(uint256 a, uint256 b) internal pure returns (uint256) { if (a == 0) { return 0; } uint256 c = a * b; assert(c / a == b); return c; } /** * @dev Integer division of two numbers, truncating the quotient. */ function div(uint256 a, uint256 b) internal pure returns (uint256) { // assert(b &gt; 0); // Solidity automatically throws when dividing by 0 uint256 c = a / b; // assert(a == b * c + a % b); // There is no case in which this doesn&#39;t hold return c; } /** * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend). */ function sub(uint256 a, uint256 b) internal pure returns (uint256) { assert(b &lt;= a); return a - b; } /** * @dev Adds two numbers, throws on overflow. */ function add(uint256 a, uint256 b) internal pure returns (uint256) { uint256 c = a + b; assert(c &gt;= a); return c; } } /** * @title SafeMath32 * @dev SafeMath library implemented for uint32 */ library SafeMath32 { function mul(uint32 a, uint32 b) internal pure returns (uint32) { if (a == 0) { return 0; } uint32 c = a * b; assert(c / a == b); return c; } function div(uint32 a, uint32 b) internal pure returns (uint32) { // assert(b &gt; 0); // Solidity automatically throws when dividing by 0 uint32 c = a / b; // assert(a == b * c + a % b); // There is no case in which this doesn&#39;t hold return c; } function sub(uint32 a, uint32 b) internal pure returns (uint32) { assert(b &lt;= a); return a - b; } function add(uint32 a, uint32 b) internal pure returns (uint32) { uint32 c = a + b; assert(c &gt;= a); return c; } } /** * @title SafeMath16 * @dev SafeMath library implemented for uint16 */ library SafeMath16 { function mul(uint16 a, uint16 b) internal pure returns (uint16) { if (a == 0) { return 0; } uint16 c = a * b; assert(c / a == b); return c; } function div(uint16 a, uint16 b) internal pure returns (uint16) { // assert(b &gt; 0); // Solidity automatically throws when dividing by 0 uint16 c = a / b; // assert(a == b * c + a % b); // There is no case in which this doesn&#39;t hold return c; } function sub(uint16 a, uint16 b) internal pure returns (uint16) { assert(b &lt;= a); return a - b; } function add(uint16 a, uint16 b) internal pure returns (uint16) { uint16 c = a + b; assert(c &gt;= a); return c; } } . zombieownership.sol . pragma solidity &gt;=0.5.0 &lt;0.6.0; import &quot;./zombieattack.sol&quot;; import &quot;./erc721.sol&quot;; import &quot;./safemath.sol&quot;; contract ZombieOwnership is ZombieAttack, ERC721 { using SafeMath for uint256; mapping (uint =&gt; address) zombieApprovals; function balanceOf(address _owner) external view returns (uint256) { return ownerZombieCount[_owner]; } function ownerOf(uint256 _tokenId) external view returns (address) { return zombieToOwner[_tokenId]; } function _transfer(address _from, address _to, uint256 _tokenId) private { ownerZombieCount[_to] = ownerZombieCount[_to].add(1); ownerZombieCount[msg.sender] = ownerZombieCount[msg.sender].sub(1); zombieToOwner[_tokenId] = _to; emit Transfer(_from, _to, _tokenId); } function transferFrom(address _from, address _to, uint256 _tokenId) external payable { require (zombieToOwner[_tokenId] == msg.sender || zombieApprovals[_tokenId] == msg.sender); _transfer(_from, _to, _tokenId); } function approve(address _approved, uint256 _tokenId) external payable onlyOwnerOf(_tokenId) { zombieApprovals[_tokenId] = _approved; emit Approval(msg.sender, _approved, _tokenId); } } . zombieattack.sol . pragma solidity &gt;=0.5.0 &lt;0.6.0; import &quot;./zombiehelper.sol&quot;; contract ZombieAttack is ZombieHelper { uint randNonce = 0; uint attackVictoryProbability = 70; function randMod(uint _modulus) internal returns(uint) { randNonce = randNonce.add(1); return uint(keccak256(abi.encodePacked(now, msg.sender, randNonce))) % _modulus; } function attack(uint _zombieId, uint _targetId) external onlyOwnerOf(_zombieId) { Zombie storage myZombie = zombies[_zombieId]; Zombie storage enemyZombie = zombies[_targetId]; uint rand = randMod(100); if (rand &lt;= attackVictoryProbability) { myZombie.winCount = myZombie.winCount.add(1); myZombie.level = myZombie.level.add(1); enemyZombie.lossCount = enemyZombie.lossCount.add(1); feedAndMultiply(_zombieId, enemyZombie.dna, &quot;zombie&quot;); } else { myZombie.lossCount = myZombie.lossCount.add(1); enemyZombie.winCount = enemyZombie.winCount.add(1); _triggerCooldown(myZombie); } } } . zombiefactory.sol . pragma solidity &gt;=0.5.0 &lt;0.6.0; import &quot;./ownable.sol&quot;; import &quot;./safemath.sol&quot;; contract ZombieFactory is Ownable { using SafeMath for uint256; using SafeMath32 for uint32; using SafeMath16 for uint16; event NewZombie(uint zombieId, string name, uint dna); uint dnaDigits = 16; uint dnaModulus = 10 ** dnaDigits; uint cooldownTime = 1 days; struct Zombie { string name; uint dna; uint32 level; uint32 readyTime; uint16 winCount; uint16 lossCount; } Zombie[] public zombies; mapping (uint =&gt; address) public zombieToOwner; mapping (address =&gt; uint) ownerZombieCount; function _createZombie(string memory _name, uint _dna) internal { uint id = zombies.push(Zombie(_name, _dna, 1, uint32(now + cooldownTime), 0, 0)) - 1; zombieToOwner[id] = msg.sender; ownerZombieCount[msg.sender] = ownerZombieCount[msg.sender].add(1); emit NewZombie(id, _name, _dna); } function _generateRandomDna(string memory _str) private view returns (uint) { uint rand = uint(keccak256(abi.encodePacked(_str))); return rand % dnaModulus; } function createRandomZombie(string memory _name) public { require(ownerZombieCount[msg.sender] == 0); uint randDna = _generateRandomDna(_name); randDna = randDna - randDna % 100; _createZombie(_name, randDna); } } . zombiefeeding.sol . pragma solidity &gt;=0.5.0 &lt;0.6.0; import &quot;./zombiefactory.sol&quot;; contract KittyInterface { function getKitty(uint256 _id) external view returns ( bool isGestating, bool isReady, uint256 cooldownIndex, uint256 nextActionAt, uint256 siringWithId, uint256 birthTime, uint256 matronId, uint256 sireId, uint256 generation, uint256 genes ); } contract ZombieFeeding is ZombieFactory { KittyInterface kittyContract; modifier onlyOwnerOf(uint _zombieId) { require(msg.sender == zombieToOwner[_zombieId]); _; } function setKittyContractAddress(address _address) external onlyOwner { kittyContract = KittyInterface(_address); } function _triggerCooldown(Zombie storage _zombie) internal { _zombie.readyTime = uint32(now + cooldownTime); } function _isReady(Zombie storage _zombie) internal view returns (bool) { return (_zombie.readyTime &lt;= now); } function feedAndMultiply(uint _zombieId, uint _targetDna, string memory _species) internal onlyOwnerOf(_zombieId) { Zombie storage myZombie = zombies[_zombieId]; require(_isReady(myZombie)); _targetDna = _targetDna % dnaModulus; uint newDna = (myZombie.dna + _targetDna) / 2; if (keccak256(abi.encodePacked(_species)) == keccak256(abi.encodePacked(&quot;kitty&quot;))) { newDna = newDna - newDna % 100 + 99; } _createZombie(&quot;NoName&quot;, newDna); _triggerCooldown(myZombie); } function feedOnKitty(uint _zombieId, uint _kittyId) public { uint kittyDna; (,,,,,,,,,kittyDna) = kittyContract.getKitty(_kittyId); feedAndMultiply(_zombieId, kittyDna, &quot;kitty&quot;); } } . zombiehelper.sol . pragma solidity &gt;=0.5.0 &lt;0.6.0; import &quot;./zombiefeeding.sol&quot;; contract ZombieHelper is ZombieFeeding { uint levelUpFee = 0.001 ether; modifier aboveLevel(uint _level, uint _zombieId) { require(zombies[_zombieId].level &gt;= _level); _; } function withdraw() external onlyOwner { address _owner = owner(); _owner.transfer(address(this).balance); } function setLevelUpFee(uint _fee) external onlyOwner { levelUpFee = _fee; } function levelUp(uint _zombieId) external payable { require(msg.value == levelUpFee); zombies[_zombieId].level = zombies[_zombieId].level.add(1); } function changeName(uint _zombieId, string calldata _newName) external aboveLevel(2, _zombieId) onlyOwnerOf(_zombieId) { zombies[_zombieId].name = _newName; } function changeDna(uint _zombieId, uint _newDna) external aboveLevel(20, _zombieId) onlyOwnerOf(_zombieId) { zombies[_zombieId].dna = _newDna; } function getZombiesByOwner(address _owner) external view returns(uint[] memory) { uint[] memory result = new uint[](ownerZombieCount[_owner]); uint counter = 0; for (uint i = 0; i &lt; zombies.length; i++) { if (zombieToOwner[i] == _owner) { result[counter] = i; counter++; } } return result; } } .",
            "url": "https://saxenism.com/web3/solidity/cryptozombies/beginner/2021/06/16/CryptoZombies-Lesson-5.html",
            "relUrl": "/web3/solidity/cryptozombies/beginner/2021/06/16/CryptoZombies-Lesson-5.html",
            "date": " ‚Ä¢ Jun 16, 2021"
        }
        
    
  
    
        ,"post6": {
            "title": "CryptoZombies - Lesson 4",
            "content": "Lesson 4: . view tells us that by running the functions, no data will be saved/changed. pure tells us that not only does the function not save any data to the blockchain, but it also doens‚Äôt read any data from the blockchain. Both of these don‚Äôt cost any gas to call if they‚Äôre called from outside the contract, but the do cost gas if called internally by another function because the calling function is eventually making changes on the blockchain. | The function modifiers can all be stacked together on a function definition, as follows: function test() external view onlyOwner anotherModifier { // Some function-y stuff } . | The payable modifier: They are a special type of functions that can recieve Ether. In Ethereum, because both the money (Ether), the data (transaction payload), and the contract code itself all live on Ethereum, it‚Äôs possible for you to call a function and pay money to the contract at the same time. This allows us to have some really cool logic, such as: requiring a certain payment to the contract in order to execute a function. Here‚Äôs an example: contract OnlineStore { function buySomething () external payable { require(msg.value == 0.01 ether); //ether is an inbuilt uint; transferStuff(msg.sender); } } . msg.value is a way to see how much Ether was sent to the contract. If a function is not marked as payable, and you try to send Ether to it, the function will reject your transaction. . | The payment can only be done to a data type that‚Äôs called address payable. Example: function withdraw() external onlyOwner() { address payable _owner = address(uint16(owner())); _owner.transfer(address(this).balance); } address(this).balance will return the total balance stored on the contract. . | A make-shift way of generating random numbers in Solidity is as follows: // Generate a random number between 1 and 100: uint randNonce = 0; uint random = uint(keccak256(abi.encodePacked(now, msg.sender, randNonce))) % 100; randNonce++; uint random2 = uint(keccak256(abi.encodePacked(now, msg.sender, randNonce))) % 100; . But, this is unsafe, because technically, this can be hacked. How? Read on: In Ethereum, when you call a function on a contract, you broadcast it to a node or nodes on the network as a transaction. The nodes on the network then collect a bunch of transactions, try to be the first to solve a computationally-intensive mathematical problem as a ‚ÄúProof of Work‚Äù, and then publish that group of transactions along with their Proof of Work (PoW) as a block to the rest of the network. Once a node has solved the PoW, the other nodes stop trying to solve the PoW, verify that the other node‚Äôs list of transactions are valid, and then accept the block and move on to trying to solve the next block. This makes our random number function exploitable. Let‚Äôs say we had a coin flip contract ‚Äîheads you double your money, tails you lose everything. Let‚Äôs say it used the above random function to determine heads or tails. (random &gt;= 50 is heads, random &lt; 50 is tails). If I were running a node, I could publish a transaction only to my own node and not share it. I could then run the coin flip function to see if I won ‚Äî and if I lost, choose not to include that transaction in the next block I‚Äôm solving. I could keep doing this indefinitely until I finally won the coin flip and solved the next block, and profit. . | One relatively safe method is to use an Oracle to access a random number from outside the Ethereum blockchain | . Solidity Code from Lesson 4 . zombieattack.sol . pragma solidity &gt;=0.5.0 &lt;0.6.0; import &quot;./zombiehelper.sol&quot;; contract ZombieAttack is ZombieHelper { uint randNonce = 0; uint attackVictoryProbability = 70; function randMod(uint _modulus) internal returns(uint) { randNonce++; return uint(keccak256(abi.encodePacked(now, msg.sender, randNonce))) % _modulus; } function attack(uint _zombieId, uint _targetId) external ownerOf(_zombieId) { Zombie storage myZombie = zombies[_zombieId]; Zombie storage enemyZombie = zombies[_targetId]; uint rand = randMod(100); if (rand &lt;= attackVictoryProbability) { myZombie.winCount++; myZombie.level++; enemyZombie.lossCount++; feedAndMultiply(_zombieId, enemyZombie.dna, &quot;zombie&quot;); } else { myZombie.lossCount++; enemyZombie.winCount++; _triggerCooldown(myZombie); } } } . zombiehelper.sol . pragma solidity &gt;=0.5.0 &lt;0.6.0; import &quot;./zombiefeeding.sol&quot;; contract ZombieHelper is ZombieFeeding { uint levelUpFee = 0.001 ether; modifier aboveLevel(uint _level, uint _zombieId) { require(zombies[_zombieId].level &gt;= _level); _; } function withdraw() external onlyOwner { address _owner = owner(); _owner.transfer(address(this).balance); } function setLevelUpFee(uint _fee) external onlyOwner { levelUpFee = _fee; } function levelUp(uint _zombieId) external payable { require(msg.value == levelUpFee); zombies[_zombieId].level++; } function changeName(uint _zombieId, string calldata _newName) external aboveLevel(2, _zombieId) ownerOf(_zombieId) { zombies[_zombieId].name = _newName; } function changeDna(uint _zombieId, uint _newDna) external aboveLevel(20, _zombieId) ownerOf(_zombieId) { zombies[_zombieId].dna = _newDna; } function getZombiesByOwner(address _owner) external view returns(uint[] memory) { uint[] memory result = new uint[](ownerZombieCount[_owner]); uint counter = 0; for (uint i = 0; i &lt; zombies.length; i++) { if (zombieToOwner[i] == _owner) { result[counter] = i; counter++; } } return result; } } . zombiefactory.sol . pragma solidity &gt;=0.5.0 &lt;0.6.0; import &quot;./ownable.sol&quot;; contract ZombieFactory is Ownable { event NewZombie(uint zombieId, string name, uint dna); uint dnaDigits = 16; uint dnaModulus = 10 ** dnaDigits; uint cooldownTime = 1 days; struct Zombie { string name; uint dna; uint32 level; uint32 readyTime; uint16 winCount; uint16 lossCount; } Zombie[] public zombies; mapping (uint =&gt; address) public zombieToOwner; mapping (address =&gt; uint) ownerZombieCount; function _createZombie(string memory _name, uint _dna) internal { uint id = zombies.push(Zombie(_name, _dna, 1, uint32(now + cooldownTime), 0, 0)) - 1; zombieToOwner[id] = msg.sender; ownerZombieCount[msg.sender]++; emit NewZombie(id, _name, _dna); } function _generateRandomDna(string memory _str) private view returns (uint) { uint rand = uint(keccak256(abi.encodePacked(_str))); return rand % dnaModulus; } function createRandomZombie(string memory _name) public { require(ownerZombieCount[msg.sender] == 0); uint randDna = _generateRandomDna(_name); randDna = randDna - randDna % 100; _createZombie(_name, randDna); } } . zombiefeeding.sol . pragma solidity &gt;=0.5.0 &lt;0.6.0; import &quot;./ownable.sol&quot;; contract ZombieFactory is Ownable { event NewZombie(uint zombieId, string name, uint dna); uint dnaDigits = 16; uint dnaModulus = 10 ** dnaDigits; uint cooldownTime = 1 days; struct Zombie { string name; uint dna; uint32 level; uint32 readyTime; uint16 winCount; uint16 lossCount; } Zombie[] public zombies; mapping (uint =&gt; address) public zombieToOwner; mapping (address =&gt; uint) ownerZombieCount; function _createZombie(string memory _name, uint _dna) internal { uint id = zombies.push(Zombie(_name, _dna, 1, uint32(now + cooldownTime), 0, 0)) - 1; zombieToOwner[id] = msg.sender; ownerZombieCount[msg.sender]++; emit NewZombie(id, _name, _dna); } function _generateRandomDna(string memory _str) private view returns (uint) { uint rand = uint(keccak256(abi.encodePacked(_str))); return rand % dnaModulus; } function createRandomZombie(string memory _name) public { require(ownerZombieCount[msg.sender] == 0); uint randDna = _generateRandomDna(_name); randDna = randDna - randDna % 100; _createZombie(_name, randDna); } } . ownable.sol . pragma solidity &gt;=0.5.0 &lt;0.6.0; /** * @title Ownable * @dev The Ownable contract has an owner address, and provides basic authorization control * functions, this simplifies the implementation of &quot;user permissions&quot;. */ contract Ownable { address private _owner; event OwnershipTransferred( address indexed previousOwner, address indexed newOwner ); /** * @dev The Ownable constructor sets the original `owner` of the contract to the sender * account. */ constructor() internal { _owner = msg.sender; emit OwnershipTransferred(address(0), _owner); } /** * @return the address of the owner. */ function owner() public view returns(address) { return _owner; } /** * @dev Throws if called by any account other than the owner. */ modifier onlyOwner() { require(isOwner()); _; } /** * @return true if `msg.sender` is the owner of the contract. */ function isOwner() public view returns(bool) { return msg.sender == _owner; } /** * @dev Allows the current owner to relinquish control of the contract. * @notice Renouncing to ownership will leave the contract without an owner. * It will not be possible to call the functions with the `onlyOwner` * modifier anymore. */ function renounceOwnership() public onlyOwner { emit OwnershipTransferred(_owner, address(0)); _owner = address(0); } /** * @dev Allows the current owner to transfer control of the contract to a newOwner. * @param newOwner The address to transfer ownership to. */ function transferOwnership(address newOwner) public onlyOwner { _transferOwnership(newOwner); } /** * @dev Transfers control of the contract to a newOwner. * @param newOwner The address to transfer ownership to. */ function _transferOwnership(address newOwner) internal { require(newOwner != address(0)); emit OwnershipTransferred(_owner, newOwner); _owner = newOwner; } } .",
            "url": "https://saxenism.com/web3/solidity/cryptozombies/beginner/2021/06/15/CryptoZombies-Lesson-4.html",
            "relUrl": "/web3/solidity/cryptozombies/beginner/2021/06/15/CryptoZombies-Lesson-4.html",
            "date": " ‚Ä¢ Jun 15, 2021"
        }
        
    
  
    
        ,"post7": {
            "title": "CryptoZombies - Lesson 3",
            "content": "Lesson 3: . After you deploy a contract to Ethereum, it is immutable. It can never be modified/updated again. For this reason, if often makes sense to have functions that will allow you to update key portions of your dApp | Ownable contract: Owners(contract creators) have special priviliges. It has the following three functions: a. When a contract is deployed, its constructor sets the owner to msg.sender (the person who deployed it) b. It adds an onlyOwner modifier, which can restirct access to certain functions to only the owner c. It allows you to transfer the contract to a new owner | Once you inherit from the Ownable contract, you can use the onlyOwner function modifier. This ensures that the function caller is indeed the contract owner or not | In Solidity, your users have to pay every time they execute a function on your DApp using a currency called gas. So, basically, users have to spend ETH in order to execute functions on your DApp. | How much gas is required to execute a function depends on how complex that function‚Äôs logic is. Each individual operation has a gas cost based roughly on how much computing resources will be required to perform that operation. The total gas cost of your function is the sum of the gas costs of all its individual operations. Therefore, code optimization is much much more important in Ethereum than in other programming languages. Because, if your code is slopp, then your users are going to pay a premium to execute your functions ‚Äì and this could add up to millions of dollars in unnecessary fees across thousand of users. | Choosing either of uint8, uint16, uint32, uint256 will result in the same gas fee because Ethereum reserves the same space for each, irrespective of what uint you choose. But you can save on costs when working with multiple uints inside of a struct. Also, for this to happen, you would want to cluster identical data types together (ie put them next to each other in the struct) | Solidity provides some native units for dealing with time. The variable now will return the current unix timestamp of the latest block (the number of seconds that have passed since January 1st 1970). Solidity also contains the time units seconds, minutes, hours, days, weeks and years. | We can pass a storage pointer to a struct as an argument to a private or internal function. | An important security practice is to examine all your public and external functions, and try to think of ways users might abuse them. Because, unless these functions have a modifier like onlyOwner, any user can call them and pass them any data they want to. | The custom function modifier (like onlyOwner) can also take some parameters. The following example will clear things up: mapping (uint =&gt; uint) public age; // Modifier that requires this user to be older than a certain age: modifier olderThan(uint _age, uint _userId) { require(age[_userId] &gt;= _age); _; } function driveCar(uint _userId) public olderThan(16, _userId) { // Some function logic } . | Remember how we used memory pointer type along with string in function parameters. Similar to memory we have calldata but it‚Äôs only available to external functions | Since view functions only needs to query your local Ethereum node to run the function, it doesn‚Äôt actually have to create a transaction on the blockchain, which would need to run on every single node, and cost gas. Therefore, view functions don‚Äôt cost any gas when they‚Äôre called externally by a user. Optimize your DApp‚Äôs gas usage for your users by using read-only external view functions wherever possible. If a view function is called internally from another function in the same contract that is not a view function, it will still cost gas. This is because the other function creates a transaction on Ethereum, and will still need to be verified from every node. So view functions are only free when they‚Äôre called externally. | One of the more expensive operations in Solidity is using storage ‚Äî particularly writes. This is because every time you write or change a piece of data, it‚Äôs written permanently to the blockchain. Forever! Thousands of nodes across the world need to store that data on their hard drives, and this amount of data keeps growing over time as the blockchain grows. So there‚Äôs a cost to doing that. In order to keep costs down, you want to avoid writing data to storage except when absolutely necessary. Sometimes this involves seemingly inefficient programming logic ‚Äî like rebuilding an array in memory every time a function is called instead of simply saving that array in a variable for quick lookups. In most programming languages, looping over large data sets is expensive. But in Solidity, this is way cheaper than using storage if it‚Äôs in an external view function, since view functions don‚Äôt cost your users any gas. (And gas costs your users real money!). An example illustrating how to declare arrays in memory: function getArray() external pure returns(uint[] memory) { // Instantiate a new array in memory with a length of 3 uint[] memory values = new uint[](3); // Put some values to it values[0] = 1; values[1] = 2; values[2] = 3; return values; } . | for loops will be preferred over mapping solutions, if it can save gas cost. | . Solidity Code from Lesson 3: . ##ownable.sol . pragma solidity &gt;=0.5.0 &lt;0.6.0; /** * @title Ownable * @dev The Ownable contract has an owner address, and provides basic authorization control * functions, this simplifies the implementation of &quot;user permissions&quot;. */ contract Ownable { address private _owner; event OwnershipTransferred( address indexed previousOwner, address indexed newOwner ); /** * @dev The Ownable constructor sets the original `owner` of the contract to the sender * account. */ constructor() internal { _owner = msg.sender; emit OwnershipTransferred(address(0), _owner); } /** * @return the address of the owner. */ function owner() public view returns(address) { return _owner; } /** * @dev Throws if called by any account other than the owner. */ modifier onlyOwner() { require(isOwner()); _; } /** * @return true if `msg.sender` is the owner of the contract. */ function isOwner() public view returns(bool) { return msg.sender == _owner; } /** * @dev Allows the current owner to relinquish control of the contract. * @notice Renouncing to ownership will leave the contract without an owner. * It will not be possible to call the functions with the `onlyOwner` * modifier anymore. */ function renounceOwnership() public onlyOwner { emit OwnershipTransferred(_owner, address(0)); _owner = address(0); } /** * @dev Allows the current owner to transfer control of the contract to a newOwner. * @param newOwner The address to transfer ownership to. */ function transferOwnership(address newOwner) public onlyOwner { _transferOwnership(newOwner); } /** * @dev Transfers control of the contract to a newOwner. * @param newOwner The address to transfer ownership to. */ function _transferOwnership(address newOwner) internal { require(newOwner != address(0)); emit OwnershipTransferred(_owner, newOwner); _owner = newOwner; } } . zombiefactory.sol . pragma solidity &gt;=0.5.0 &lt;0.6.0; import &quot;./ownable.sol&quot;; contract ZombieFactory is Ownable { event NewZombie(uint zombieId, string name, uint dna); uint dnaDigits = 16; uint dnaModulus = 10 ** dnaDigits; uint cooldownTime = 1 days; struct Zombie { string name; uint dna; uint32 level; uint32 readyTime; } Zombie[] public zombies; mapping (uint =&gt; address) public zombieToOwner; mapping (address =&gt; uint) ownerZombieCount; function _createZombie(string memory _name, uint _dna) internal { uint id = zombies.push(Zombie(_name, _dna, 1, uint32(now + cooldownTime))) - 1; zombieToOwner[id] = msg.sender; ownerZombieCount[msg.sender]++; emit NewZombie(id, _name, _dna); } function _generateRandomDna(string memory _str) private view returns (uint) { uint rand = uint(keccak256(abi.encodePacked(_str))); return rand % dnaModulus; } function createRandomZombie(string memory _name) public { require(ownerZombieCount[msg.sender] == 0); uint randDna = _generateRandomDna(_name); randDna = randDna - randDna % 100; _createZombie(_name, randDna); } } . zombiefeeding.sol . pragma solidity &gt;=0.5.0 &lt;0.6.0; import &quot;./zombiefactory.sol&quot;; contract KittyInterface { function getKitty(uint256 _id) external view returns ( bool isGestating, bool isReady, uint256 cooldownIndex, uint256 nextActionAt, uint256 siringWithId, uint256 birthTime, uint256 matronId, uint256 sireId, uint256 generation, uint256 genes ); } contract ZombieFeeding is ZombieFactory { KittyInterface kittyContract; function setKittyContractAddress(address _address) external onlyOwner { kittyContract = KittyInterface(_address); } function _triggerCooldown(Zombie storage _zombie) internal { _zombie.readyTime = uint32(now + cooldownTime); } function _isReady(Zombie storage _zombie) internal view returns (bool) { return (_zombie.readyTime &lt;= now); } function feedAndMultiply(uint _zombieId, uint _targetDna, string memory _species) internal { require(msg.sender == zombieToOwner[_zombieId]); Zombie storage myZombie = zombies[_zombieId]; require(_isReady(myZombie)); _targetDna = _targetDna % dnaModulus; uint newDna = (myZombie.dna + _targetDna) / 2; if (keccak256(abi.encodePacked(_species)) == keccak256(abi.encodePacked(&quot;kitty&quot;))) { newDna = newDna - newDna % 100 + 99; } _createZombie(&quot;NoName&quot;, newDna); _triggerCooldown(myZombie); } function feedOnKitty(uint _zombieId, uint _kittyId) public { uint kittyDna; (,,,,,,,,,kittyDna) = kittyContract.getKitty(_kittyId); feedAndMultiply(_zombieId, kittyDna, &quot;kitty&quot;); } } . zombiehelper.sol . pragma solidity &gt;=0.5.0 &lt;0.6.0; import &quot;./zombiefeeding.sol&quot;; contract ZombieHelper is ZombieFeeding { // 1. Define levelUpFee here modifier aboveLevel(uint _level, uint _zombieId) { require(zombies[_zombieId].level &gt;= _level); _; } // 2. Insert levelUp function here function changeName(uint _zombieId, string calldata _newName) external aboveLevel(2, _zombieId) { require(msg.sender == zombieToOwner[_zombieId]); zombies[_zombieId].name = _newName; } function changeDna(uint _zombieId, uint _newDna) external aboveLevel(20, _zombieId) { require(msg.sender == zombieToOwner[_zombieId]); zombies[_zombieId].dna = _newDna; } function getZombiesByOwner(address _owner) external view returns(uint[] memory) { uint[] memory result = new uint[](ownerZombieCount[_owner]); uint counter = 0; for (uint i = 0; i &lt; zombies.length; i++) { if (zombieToOwner[i] == _owner) { result[counter] = i; counter++; } } return result; } } .",
            "url": "https://saxenism.com/web3/solidity/cryptozombies/beginner/2021/06/14/CryptoZombies-Lesson-3.html",
            "relUrl": "/web3/solidity/cryptozombies/beginner/2021/06/14/CryptoZombies-Lesson-3.html",
            "date": " ‚Ä¢ Jun 14, 2021"
        }
        
    
  
    
        ,"post8": {
            "title": "CryptoZombies - Lesson 2",
            "content": "Lesson 2: . Addresses: The ethereum blockchain is made up of accounts, which you can think of as bank accounts. An account has a balance of Ether, and you can send and recieve Ether payments to other accounts, just like your bank account can wire transfer money to other bank accounts Each bank account has an address which you can think of like a bank account number.Its a unique identifier that points to an account. An address is owned by a specific user or a smart contract. Mapping: So we can use it as a unique ID for ownership of our zombies. When a user creates new zombies by interacting with our app, we‚Äôll set ownership of those zombies to the Ethereum address that called the function A mapping is essentially a key-value store for storing and looking up data mapping(uint =&gt; string) userIdToName; | msg.sender In solidity, there are certain global variables that are available to all functions. One of them is msg.sender msg.sender refers to the address of the person (or the smart contract) who called the current function In solidity, function execution always needs to start with an external caller. A contract will just sit on the blockchain doing nothing until someone calls one of its functions. So, there will always be a msg.sender | require is a keyword in Solidity used for condition checking. If this condition is met, then only a function is executed otherwise, it terminates with an error. Example: function sayHiToVitalik (string memory _name) public returns (string memory) { require(keccak256(abi.encodePacked(_name)) == keccak256(abi.encodePacked(&quot;Vitalik&quot;))); return &quot;Hi Vitalik, thank you for Ethereum!!&quot;; } . | Solidity does not support string comparison natively, so we simply compare the keccak256 hashes of the two strings. | Solidity supports inheritence. Hence, instead of writing one big long contract, it makes sense to split your code logic across multiple contracts to organize the code. | Really cool and succint inheritence syntax: contract cat is animal { } // Here the contract cat inherits from the contract animal :D . | Syntax to import one file into another: import &#39;./someOtherContract.sol&#39;; contract newContract is someOtherContract { } . | In solidity, there are two locations in which you can store variables - in storage and in memory. Storage refers to variables permanently stored on the blockchain. Memory variables are temporary, and are erased between external function calls to your contract. Think of it like a computer‚Äôs Hard Disk vs RAM Example: contract SandwichFactory { struct Sandwich { string name; string status; } Sandwich[] sandwiches; function eatSandwich(uint _index) public { // Sandwich mySandwich = sandwiches[_index]; // ^ Seems pretty straightforward, but solidity will give you a warning // telling you that you should explicitly declare storage or memory here. // So instead, you should declare with the storage keyword, like: Sandwich storage mySandwich = sandwiches[_index]; // ...in which case mySandwich is a pointer to sandwiches[_index] // in storage, and... mySandwich.status = &quot;Eaten!&quot;; // ...this will permanently change `sandwiches[_index]` on the blockchain. // If you just want a copy, you can use memory: Sandwich memory anotherSandwich = sandwiches[_index + 1]; // ...in which case anotherSandwich will simply be a copy of the // data in memory, and... anotherSandwich.status = &quot;Eaten!&quot;; // ...will just modify the temporary variable and have no effect // on sandwiches[_index + 1]. But you can do this: sandwiches[_index + 1] = anotherSandwich; // ...if you want to copy the changes back into blockchain storage. } } . | For a struct People such as: struct People { string name; uint age; } People randomMan = People(&quot;Sam&quot;, &quot;22&quot;); . You can access the properties of this struct as follows: randomMan.age or randomMan.name . | Types of functions in solidity: a. Private b. Internal c. Public d. External internal is the same as private, except that it‚Äôs also accessible to contracts that inherit from this contract. external is the same public, except that these functions can ONLY be called outside the contract. | Interacting with other smart contracts on the Ethereum blockchain: a. Define an interface (almost the same syntax as that of a contract, but only function signatures are mentioned here.) b. Only those function signatures need to be written in the interface, that we actually need to call c. Grab the address of the smart contract, you want to call the function from d. Initialise the interface you built with this address (much like creating an object) e. Example: contract NumberInterface { function getNum(address _myAddress) public view returns (uint); } contract MyContract { address NumberInterfaceAddress = 0xabcde122...... NumberInterface numberContract = NumberInterface(NumberInterfaceAddress); function someFunction() public { uint num = numberContract.getNum(msg.sender); } } . | In Solidity you can return more than one value from a function :D | This example illustrates, how we manage multiple return values from Solidity function: function multipleReturns() internal returns(uint a, uint b, uint c) { return (1, 2, 3); } function processMultipleReturns() external { uint a; uint b; uint c; // This is how you do multiple assignment: (a, b, c) = multipleReturns(); } // Or if we only cared about one of the values: function getLastReturnValue() external { uint c; // We can just leave the other fields blank: (,,c) = multipleReturns(); } . . | Solidity code from Lesson2 . zombiefactory.sol . pragma solidity &gt;= 0.8.4; contract ZombieFactory { event NewZombie(uint zombieId, string name, uint dna); uint dnaDigits = 16; uint dnaModulus = 10 ** dnaDigits; //(10^16) struct Zombie { string name; uint dna; } Zombie[] public zombies; mapping (uint =&gt; address) public zombieToOwner; mapping (address =&gt; uint) ownerZombieCount; function _createZombie(string memory _name, uint _dna) internal { zombies.push(Zombie(_name, _dna)); uint id = zombies.length - 1; zombieToOwner[id] = msg.sender; ownerZombieCount[msg.sender]++; emit NewZombie(id, _name, _dna); } function _generateRandomDna(string memory _str) private view returns (uint) { uint rand = uint(keccak256(abi.encodePacked(_str))); return rand % dnaModulus; } function createRandomZombie(string memory _name) public { require(ownerZombieCount[msg.sender] == 0); uint randDna = _generateRandomDna(_name); randDna = randDna - randDna % 100; _createZombie(_name, randDna); } } . zombiefeeding.sol . pragma solidity ^ 0.8.4; import &quot;lesson2_zombiefactory.sol&quot;; contract KittyInterface { function getKitty(uint256 _id) external view returns ( bool isGestating, bool isReady, uint256 cooldownIndex, uint256 nextActionAt, uint256 siringWithId, uint256 birthTime, uint256 matronId, uint256 sireId, uint256 generation, uint256 genes ); } contract ZombieFeeding is ZombieFactory { address ckAddress = 0x06012c8cf97BEaD5deAe237070F9587f8E7A266d; KittyInterface kittyContract = KittyInterface(ckAddress); function feedAndMultiply(uint _zombieId, uint _targetDna, string memory _species) public { require(msg.sender == zombieToOwner[_zombieId]); Zombie storage myZombie = zombies[_zombieId]; _targetDna = _targetDna % dnaModulus; uint newDna = (myZombie.dna + _targetDna) / 2; if (keccak256(abi.encodePacked(_species)) == keccak256(abi.encodePacked(&quot;kitty&quot;))) { newDna = newDna - newDna % 100 + 99; } _createZombie(&quot;NoName&quot;, newDna); } function feedOnKitty(uint _zombieId, uint _kittyId) public { uint kittyDna; (,,,,,,,,,kittyDna) = kittyContract.getKitty(_kittyId); feedAndMultiply(_zombieId, kittyDna, &quot;kitty&quot;); } } .",
            "url": "https://saxenism.com/web3/solidity/cryptozombies/beginner/2021/06/13/CryptoZombies-Lesson-2.html",
            "relUrl": "/web3/solidity/cryptozombies/beginner/2021/06/13/CryptoZombies-Lesson-2.html",
            "date": " ‚Ä¢ Jun 13, 2021"
        }
        
    
  
    
        ,"post9": {
            "title": "CryptoZombies - Lesson 1",
            "content": "Lesson 1: . Solidity code is encapsulated in contracts. A contract is the fundamental building block of Ethereum applications. All variables and functions belong to a contract and this will be the starting point of all projects | State Variables: Permanently stored in contract storage (they are written to the Ethereum Blockchain) Think of declaring state variables like writing to a DB | Arithmetic operations: x+y, x-y, x*y, x/y, x%y, x**y(same as x^y) | structs struct Person { uint age; string name; } . | Arrays {Possible to create an array of structs as well as native data types} Fixed arrays -&gt; uint [2] fixedArr Dynamic arrays -&gt; uint [] dynamicArr If an array is declared as public, other contracts can read from but not write to this array | function createZombies (string memory _name, uint _dna) public { underscore is a naming convention to separate the private variables from the global variables(_name) } . Notice the word memory along with the string parameter, it signifies that _name would be memory and not in stack, therefore would not be written to the blockchain, hence cheaper The memory keyword is required for reference type varialbles: arrays, structs, mapping, strings, etc. . | Pushing to the array: Person Satoshi = Person(172, &quot;Satoshi&quot;); people.push(Satoshi); . | In solidity, all functions are public by default. Good practice is to intially make all the functions private and then only make public the functions you want to expost to the world Convetion to start private functions with underscore (function _generateZombieID()) | Return values function sayHello() public returns (string memory) { } . If a function does not change any values, we can term it as a view function. [function sayHello() public view returns (string memory) {}] Pure functions =&gt; not accessing any data from the contract. . | Keccak256 and typecasting: Ethereum has the hash function keccak 256 built-in, which is a version of SHA3. keccak256 expects a single parameter of type bytes This means we have to ‚Äúpack‚Äù any parameter before calling keccak256 | Compiler supports typecasting var = uint8(var) =&gt; This shit | Events are a way for your contract to communicate to your app front-end that something has happened on the blockchain, which can be listening for certain events and take actions when they happen Example declaration: event IntegersAdded(uint x, uint y, uint result); //Include input and ouputs to a function function add(uint _x, uint _y) public returns (uint) { uint result = _x + _y; emit IntegersAdded(_x, _y, result); return result; } . | . Solidity code from Lesson 1 . pragma solidity ^ 0.8.0; contract ZombieWorld { event NewZomie(uint zombieId, string name, uint dna); uint dnaDigits = 16; uint dnaModulus = 10 ** dnaDigits; struct Zombie { string name; uint dna; } Zombie[] public zombies; function _createZombie(string memory _name, uint _dna) private { zombies.push(Zombie(_name, _dna)); uint id = zombies.length - 1; emit NewZomie(id, _name, _dna); } function _generateRandomDna(string memory _str) private view returns (uint) { uint rand = uint(keccak256(abi.encodePacked(_str))); return rand % dnaModulus; } function createRandomZombie(string memory _name) public { uint randDna = _generateRandomDna(_name); _createZombie(_name, randDna); } } .",
            "url": "https://saxenism.com/web3/solidity/cryptozombies/beginner/2021/06/12/Cryptozombies-Lesson-1.html",
            "relUrl": "/web3/solidity/cryptozombies/beginner/2021/06/12/Cryptozombies-Lesson-1.html",
            "date": " ‚Ä¢ Jun 12, 2021"
        }
        
    
  
    
        ,"post10": {
            "title": "An Example Markdown Post",
            "content": "Example Markdown Post . Basic setup . Jekyll requires blog post files to be named according to the following format: . YEAR-MONTH-DAY-filename.md . Where YEAR is a four-digit number, MONTH and DAY are both two-digit numbers, and filename is whatever file name you choose, to remind yourself what this post is about. .md is the file extension for markdown files. . The first line of the file should start with a single hash character, then a space, then your title. This is how you create a ‚Äúlevel 1 heading‚Äù in markdown. Then you can create level 2, 3, etc headings as you wish but repeating the hash character, such as you see in the line ## File names above. . Basic formatting . You can use italics, bold, code font text, and create links. Here‚Äôs a footnote 1. Here‚Äôs a horizontal rule: . . Lists . Here‚Äôs a list: . item 1 | item 2 | . And a numbered list: . item 1 | item 2 | Boxes and stuff . This is a quotation . . You can include alert boxes ‚Ä¶and‚Ä¶ . . You can include info boxes Images . . Code . You can format text and code per usual . General preformatted text: . # Do a thing do_thing() . Python code and output: . # Prints &#39;2&#39; print(1+1) . 2 . Formatting text as shell commands: . echo &quot;hello world&quot; ./some_script.sh --option &quot;value&quot; wget https://example.com/cat_photo1.png . Formatting text as YAML: . key: value - another_key: &quot;another value&quot; . Tables . Column 1 Column 2 . A thing | Another thing | . Tweetcards . Altair 4.0 is released! https://t.co/PCyrIOTcvvTry it with: pip install -U altairThe full list of changes is at https://t.co/roXmzcsT58 ...read on for some highlights. pic.twitter.com/vWJ0ZveKbZ . &mdash; Jake VanderPlas (@jakevdp) December 11, 2019 Footnotes . This is the footnote.¬†&#8617; . |",
            "url": "https://saxenism.com/markdown/2020/01/14/test-markdown-post.html",
            "relUrl": "/markdown/2020/01/14/test-markdown-post.html",
            "date": " ‚Ä¢ Jan 14, 2020"
        }
        
    
  

  
  

  
      ,"page1": {
          "title": "About Me",
          "content": "This website is powered by fastpages 1. . a blogging platform that natively supports Jupyter notebooks in addition to other formats.¬†&#8617; . |",
          "url": "https://saxenism.com/about/",
          "relUrl": "/about/",
          "date": ""
      }
      
  

  

  
  

  

  
  

  

  
  

  
  

  

  
  

  
      ,"page11": {
          "title": "",
          "content": "Sitemap: {{ ‚Äúsitemap.xml‚Äù | absolute_url }} | .",
          "url": "https://saxenism.com/robots.txt",
          "relUrl": "/robots.txt",
          "date": ""
      }
      
  

}