{
  
    
        "post0": {
            "title": "Smart Contract Development - Best Practices",
            "content": "General Contract Development Guidelines (Best Practices) . Smart contract programming requires a different engineering mindset than what you may be used to. . The cost of failure is high and changes can be difficult, making it in some ways similar to hardware programming or financial services programming rather than web or mobile app development. . It is therefore not enough to defend against known vulnerabilities. Instead you will need to learn a new philosophy of development. . Prepare for Failure . Place circuit breakers | Manage money at risk (rate limiting, maximum usage,etc) | Effective mechanism for proxy upgrades | . Stay up to Date . Check your contracts for any new bug as soon as it is discovered | Keep on upgrading all tools and libraries | Adopt new security techniques that emerge (and seem useful) | . Keep it simple . Keep contract logic simple. Modularize code. Use already written code, use as many lego blocks as you can, before writing custom logic | Clarity over performance (Debatable) For example one could argue that the OpenSea Seaport contract is so damned performant that it affects the auditability of the contracts. But realise the fact that the Seaport contract will be deployed on the Ethereum mainnet and will be used to mint hundereds of thousands of NFTs, saving the users millions of dollars over the course of time. . So, based on the nature of your contract, do have healthy, sane discussions on whether you will place more impetus on performance or clarity. . | Roll out in phases. Have a bug bounty in place, test your code-base thoroughly and immediately add relevant tests to your codebase as soon as a new attack is discovered. | . Blockchain Properties . Randomness can be gamified. | Timestamps are imprecise. Miners can influence the time of execution of a txn within a margin of several seconds | Beware of external calls. Private data is not actually private and public functions can be called by anyone in any order. | Prefer reusing contract code only when you have proven previously-deployed contracts which you own. Otherwise go for duplication of code. Efforts such as OpenZeppelin‚Äôs Solidity Library seek to provide patterns such that secure code can be re-used without duplication . | . Development best practices: . External calls are very risky. Try and avoid doing that, prefer duplicating code over using a call to an external contract. | And when you absolutely have to do that, make sure that the contract is owned/maintained/managed by a trusted party. | Always mark your function making external calls as unsafe via comments and naming convention | Avoid making state changes after the external call. The usual re-entrancy attack and following the check-effects-interactions pattern circus. | . | | .",
            "url": "http://saxenism.com/markdown/smart-contract/solidity/security/development/best-practices/2022/08/28/General-Contract-Development-Guidelines.html",
            "relUrl": "/markdown/smart-contract/solidity/security/development/best-practices/2022/08/28/General-Contract-Development-Guidelines.html",
            "date": " ‚Ä¢ Aug 28, 2022"
        }
        
    
  
    
        ,"post1": {
            "title": "DeFi TITS - A Primer on Testing",
            "content": "The International Testing Standard (TITS) for DeFi . DeFi Testing is broken. Doesn&#39;t matter how many auditors had a stab at your protocol, if you haven&#39;t sufficiently tested your protocol, you are basically gambling with your user&#39;s funds. Creating a repo to publicly critique the quality of the test suite of major DeFi protocols. . &mdash; Rahul Saxena ü¶Äü¶Ä (@saxenism) July 27, 2022 Mission Statement . I believe that protocols need to be held to a higher standard of testing. Web3 protocols are decentralised, therefore there are no centralised authorities, and subsequently there is no regulatory pressure on the protocols to do quality checks on their protocols. . Is this an issue? YES Is this a big issue?YES . Why? . Well, because, speaking strictly from an economic perspective, it makes much more sense for a protocol to use its time and developer resources on shipping a v2 of their protocol once the initial set of smart contracts are coded rather than spending it on testing their protocol. The protocols presently, try to, conviniently shift the burden of testing and quality assurance on the auditing firms and sometimes on insurance firms. However, Auditing + Insurance is still not enough to offer the level of peace of mind that people should have on software that handles their money. . Therefore, the development team, that is the most intimately familar with the code base, must make it a sacred duty of theirs (just like doctors take the Hippocratic Oath) to test their code to the best of knowledge and ability. . All in all, these softwares (DeFi protocols) handle the hard earned money of everyday Joes like you and me (and also money of stupid funds like 3AC, but yeah, you get the point) so, we cannot let the protocols continue with lax testing, because not everything can and should be viewed with an economic lens, somethings should exist simply because of personal or community ethics. . It does not matter (much) how many auditors have had a stab at your protocol, you, as a developer, do not really understand if your protocol really works and is robust enough to take on the uncertainities of the real world if you have not tested your protocol thoroughly. . Therefore, with this repository, I aim to create a certain set of testing standards that all DeFi protocols should strive to meet. . I plan to create this set of standards via iterations. Iterations of publicly critiquing leading DeFi protocols that are in use today, so that the up and coming protocols in the same space can get an idea and inspiration for the level of testing that the entire community expects out of a protocol that claims to handle money. . List of protocols being evaluated . Maple Finance | Random tid bits about traditional testing that I have picked up‚Ä¶ . This is definitely not molded for web3 yet, but consider this a good starting point if you haven‚Äôt formally studied Software Engineering. . Testing of software is an extremely imaginative and cognitively demanding task, more so in DeFi. So let your imagination go wild and gather ideas regarding testing from any walk of life, science, religion, parenting, social sciences, etc. Just about everything is fair game in testing. . 1. Old wisdom related to testing . 1.1 Presence of bugs . Testing can esure that defects are present but it cannot prove that a particular software is bug-free. Which isn‚Äôt something super nice, but I‚Äôm coping too. . 1.2 None can do exhaustive testing . Your software can never be tested for every imaginable and possible test cases. Trust me fellow crypto bro, you cannot. . 1.3 Test Early . Earlier you test, lesser you‚Äôll cry. . 1.4 Defect Clustering . Pareto principle but for origin of software bugs. . 1.5 Pesticide Paradox . Don‚Äôt be an idiot and test the same thing over and over with different methods. Find novel ways to screw with your protocol. . 1.6 Testing is context-dependent . Every protocol does something special. Test the shit out of that. . 1.7 Absence of errors fallacy . Just like your hot and caring girlfriend, a 100% bug-free software exists only in your imagination. . 1. Why testing is important . Saves you and your users from getting rekt. | Hoping for your protocol‚Äôs success without adequate testing is like going into a gunfight without a bulletproof vest and hoping you don‚Äôt get shot. | Time and effort spent on testing can be leveraged to get better terms when you get your protocol insured. | In short, you‚Äôll get your lambo only wen you test. | . Thank you for coming to my TED talk. Bye. . Types of testing . Functional and Non Functional . Non Function includes . Testing the Documentation (which includes) Instructions | Examples | Messages | Samples | . | Installation Testing | Performance Testing Load Testing | Spike Testing | Stress Testing | Endurance Testing | . | Reliability Testing Feature Testing | Regression testing | Load Test | Objectives Testing | . | Security Testing (web2 stuff) Access to application | Data Protection | Brute FOrce | SQL Injection | Service Point | Session Management | Error Handling | Specific Risky Functionalities | . | . 2. SDLC . Requirement | Analysis (outcome from this phase is SRS) | Design (HLD and LLD) | Coding | Testing | Deployment and all | . 2.1 Waterfall Model . Sequential design process. One way street, so back tracking is not possible. . . 2.2 Spiral Model . Combination of iterative development process model and sequential linear development model. . . 3. Validation vs Verification . Verification Validation . Methods involve: review, inspection, unit testing &amp; integration testing | Involves testing the entire system (system testing) | . Usually done by developers while developing | Usually done by tester and after developing of the product by developers | . Concerned with the phase containment of errors | Concerned with making the final product error free | . Involves static and dynamic analysis of code | Involves only dynamic analysis of code | . 4. Types of software testing . 4.1 Unit Testing . Can be done in the development phase itself. Unit means a particularly small piece of (preferrably independent) code such as a function, small module etc. . Smallest element of the software is a unit and testing each of those units is unit testing. . 4.2 Integration Testing . Combine different units of code and test whether they work together as expected to produce the desired output or not. . 4 common integration testing startegies are as follows: . 4.2.1 Big Bang Testing . All units are linked at once, resulting in a complete system. Here, it is difficult to isolate any errors found. . 4.2.2 Top Down . Higher level modules are tested first after which the lower level modules are tested. Higher level modules refer to the main modules and lower level refers to the sub modules. . Stubs (temporary modules) are used to simulate the behaviour of the lower-level modules that are not yet integrated. . Used when software needs to interact with an external system. . 4.2.3 Bottom Up . Lower level modules are tested first and then the higher level modules. . This approach uses test drivers which are mainly used to initiate and pass the required data to the sub modules, implying we pass mock data that should ideally have come from (the not yet implemented) higher modules. . 4.2.4 Mixed (Sandwiched integration testing) . A mixed integration testing follows a combination of top down and bottom-up testing approaches. . 4.3 System Testing or End-to-End Testing . Testing the entire system. Here, we navigate all the necessary modules of an application and check if the end features or the end business works fine, and test the product as a whole system. . 4.3.1.1 Alpha Testing . The testers are people who have built the product. | Done before releasing the product. | Involves both white box and black box testing | . 4.3.1.2 Beta Testing . Beta testing is performed by a select set of clients who are not part of the organization. | User input on the product is collected to ensure the product is ready for real time users | Commonly involves only black box testing | . 4.3.2 Acceptance Testing . It is a formal testing according to user needs, requirements and business processes conducted to determine whether a system satisfies the acceptance criteria or not and to enable the users, customers or other authorized entities to determine whether to accept the system or not. . Smoke Testing or Build Verification Testing . Subset of acceptance testing | . Smoke Testing Sanity Testing . Smoke testing is done to assure that the acute functionalities of program is working fine. | Sanity testing is done to check the bugs have been fixed after the build. | . Smoke testing is documented. | Sanity testing isn‚Äôt documented. | . Smoke testing is done to measures the stability of the system/product by performing testing. | Sanity testing is done to measures the rationality of the system/product by performing testing. | . Smoke testing can be performed either manually or by using automation tools. | Sanity testing is commonly executed manually, not by using any automation approach. | . Smoke testing is used to test all over function of the system/product. | Sanity testing is used in the case of only modified or defect functions of system/products. | . Smoke testing is performed when new product is built. | Sanity testing is conducted after the completion of regression testing. | . 4.3.3 Mutation Testing . Type of white box testing | Extremely costly and time consuming but also extremely efficient in finding errors and ambiguities | In this type of testing, you slightly change the value/logic/statements in your code and see if you get the expected output in your tests | . 4.3.4 Performance / Non functional Testing . Non-functional testing is defined as a type of software testing to check non-functional aspects of a software application. It is designed to test the readiness of a system as per nonfunctional parameters which are never addressed by functional testing. . This testing tests the following things (among others): . Volume | Load | Stress | Security | Configuration | Compatibility (BrowserStack :P) | Recovery | Installation etc | . 4.3.5 Recovery Testing in Software Testing . Recovery testing is a type of system testing which aims at testing whether a system can recover from failures or not. | To ensure that a system is fault-tolerant and can recover well from failures, recovery testing is important to perform. | . 4.4 Regression Testing . Regression testing is the process of testing the modified parts of the code and the parts that might get affected due to the modification to ensure that no new errors have been introduced in the software after the modifications have been made. . 4.4.1 Techniques for the selection of test cases for regression testing . Select all test cases (Most thorough but inefficient approach) | Select test cases randomly (Dangerous approach) | Select modification traversing test cases (Huge upfront work required to identify these test cases) | Select higher priority test cases (Assign priority values to all your tests, then re-test all your highest priority tests) | . 4.4.2 Sanity Testing . Subset if regression testing | Done to ensure that the code changes that have been made are working properly or not | Focus of the team during sanity testing is to validate the functionality of the application and not detailed testing | Usually performed on builds where the production deployment is required immediately like a critical bug fix. | Performed only after the software product has passed the smoke test and the QA team has accepted for further testing | . 5. STLC (Software Testing Life Cycle) . Requirement Analysis (Truly truly understand what your protocol is supposed to do) | Test Planning / Strategy Phase (Based on the context of the protocol in question, zero in on a testing strategy) | Test Case Development (This should take the maximum amout of time. List down all test cases that you think are appropriate.) | Environment Setup (Independent of other stages) (Don‚Äôt tell me you don‚Äôt already have Forge installed) | Test Execution (Code up all the test cases you came up with earlier. You can do back and forth between Test Execution and Case Development phase, but try to keep it minimal) | Test Cycle Closure (Create a good report. Remember, chads keep their work presentable) | . 6. Non Functional Testing . This is based on customer expectations as opposed to functional testing which is based on customer requirements. | Non functional testing describes how the product works rather that what the product does | Includes things like performance testing, scalability, volume testing, load testing, stress testing etc. | . 6.1 Performace Testing . Ensures software application will perform well under their expected workload | Goal is not to find bugs but to elimiate performance bottle-necks | Provides accurate information about the speed, scalability and stability of the software | Types of performance testing types Load Testing (Multiple users access application simultaneously) | Stress Testing | Endurance Testing | Spiking Testing | Volume &amp; Scalability Testing | . | Pay attention to: Long load time | Poor response time | Poor scalability | Bottlenecking | . | Examples of performance Test cases: Verify response time is not more than 4 seconds when 1000 users access the website simultaneously | Check the maximum number of users that the application can handle before it crashes | Verify response time of the application under low, normal, moderate and heavy load conditions | . | . 6.2 Cross browser Tests and Mobile Testing and API Testing . See if this is applicable and test if you have the resources to do so. . Types of API Testing . Functionality Testing | Reliability Testing | Load Testing | UI/UX Testing | Interoperability Testing | Security Testing | Penetration Testing | Negative Testing | . 7. Agile Testing (Test Driven Development (TDD)) . Testing is continuous | Continuous Feedback | Decreased time of feedback response | Less documentation | Test Drive | Simplified Code | . . 7. Software Testing Documentation . 7.1 Test Plan . Provides the outline strategy which will be implemented for testing the application and also the resources that will be required. Test environement will also be described. . Make sure that you also set up a defect/bug life cycle . 7.2 Test Scenario . Notifies the area in which your application will experiment . 7.3 Test Case . Collected steps and conditions with inputs that can be implemented at the time of testing. . 7.4 Traceability Matrix . A table where you can relate test case IDs with protocol requirement IDs. . 8. Defect Management Process (What to do when you find bugs) . Detect the defect | Formulate the bug report | Fix bug | Bug list creation (so that, yk, history doesn‚Äôt repeat itself and everyone sees that you have 3 brain cells) | . It is important to note in the first two points, whenever you encounter a bug, you have to reach to the root cause of the bug and report that. Because, it is very much possible that the actual coding error that caused the bug might create many more bugs in the future. . In short, treat the root cause and not just the symptoms. . 9. When to choose manual testing . 9.1 Exploratory Testing . Carried out by domain experts. Minimal planning . 9.2 Usability Testing . User friendliness of an app . 9.3 Ad Hoc Testing . Informal testing. No documents are followed. . 9.4 How to do manual testing . Understand the requirements | Write the test cases | Conducting the tests | Log Good Bug Reports | Report the results (Detailed test report) | What to automate? . Repetitive Task | Capturing Results | Data Entry Tasks | Timing or Screening Responsiveness | Non functional Testing | Environment Setup/Tear down | . Approaches to Test Automation (Look them up) . Code driven Testing | Graphical User Interface | Framework Approach Linear Scripting framework | Data driven framework | Keyword driven framework | Modular testing framework | Hybrid Testing Framework | . | .",
            "url": "http://saxenism.com/defi/testing/web3/forge/defi-tits/2022/08/28/A-Primer-To-Testing.html",
            "relUrl": "/defi/testing/web3/forge/defi-tits/2022/08/28/A-Primer-To-Testing.html",
            "date": " ‚Ä¢ Aug 28, 2022"
        }
        
    
  
    
        ,"post2": {
            "title": "Enums",
            "content": "What are enums in Solidity? . enums or members of enumerated lists, in Solidity work much like enums in any other language. For me, it is basically a tool to reduce the stress on my mental RAM while writing code or smart contracts. . Typical Use Case: . Suppose you want to give your user an option to choose his favorite squad among 9 available options. The available options would be: . Black Bull | Silver Eagle | Blue Rose | Golden Dawn | Green Mantis | Crimson Lion | Aqua Deer | Purple Orca | Coral Peacock | . Suppose you intend to use the variable favSquad to denote your user‚Äôs favorite Black Clover squad and use that variable in subsequent logic. . One option (particularly messy one) would be to allow users to enter strings that denote their favorite squads, but that would bring forth a whole new hell of matching proper cases (upper cases and lower cases), also someone could enter a string that is out of scope, like Spade Kingdom for example. . Another option would be to assign numbers to each squad (0-8) based on their index, most probably like a mapping. That would work, but you‚Äôll have to always remember which number represents which squad while coding, which would be pretty uncomfortable. . Hence, we pivot towards using enums. Enums restrict a variable to have one of only a few predefined values. The values in this enumerated list are called enums. With the use of enums it is possible to reduce the number of bugs in your code. This helps you to not make a mistake, to enter something out of the domain, while entering data and also improves the program readability. . For example, this is how we would use enums: . pragma solidity ^ 0.8.0; contract testEnums { enum CloverSquad { BlackBull, GoldenDawn, SilverEagle, BlueRose, CrimsonLion, GreenMantis, CoralPeacock, PurpleOrca, AquaDeer } CloverSquad favSquad; CloverSquad firstRankedSquad = CloverSquad.GoldenDawn; function getFirstRankedSquad() public view returns (CloverSquad) { return firstRandkedSquad; } } . Taking enum inputs and checking invalid inputs . A question that might arise in your minds (it did in mine too üòÖ) is how do we take enums as input from the user of our smart contract. We do this by typecasting the enums and checking if it is out of range or not. . Example: . // Yes, you can use your enums in mappings. mapping (address =&gt; CloverSquad) public playerSquad; function selectFavoriteSquad(uint userFavSquad) external { require(userFavSquad &lt;= uint(CloverSquads.AquaDeer), &quot;Choose from 0 to 8&quot;); playerSquad[msg.sender] = CloverSquad(userFavSquad); // Further Logic.... } . Further Reading . That is about everything that you will need to know about enums to be well on your way, but if you really want to get deeper into enums, I would suggest reading this incredibly detailed article on enums. . Thank you &amp; Godspeed. .",
            "url": "http://saxenism.com/web3/solidity/enums/beginner/2021/06/16/Enums-In-Solidity.html",
            "relUrl": "/web3/solidity/enums/beginner/2021/06/16/Enums-In-Solidity.html",
            "date": " ‚Ä¢ Jun 16, 2021"
        }
        
    
  
    
        ,"post3": {
            "title": "CryptoZombies - Lesson 5",
            "content": "Lesson 5: . Tokens on Ethereum: A token on Ethereum is basically just a smart contract that follows some common rules ‚Äî namely it implements a standard set of functions that all other token contracts share. The token standard that‚Äôs a much better fit for crypto-collectibles like CryptoZombies ‚Äî is called ERC721 tokens. ERC721 tokens are not interchangeable since each one is assumed to be unique, and are not divisible. You can only trade them in whole units, and each one has a unique ID. using a standard like ERC721 has the benefit that we don‚Äôt have to implement the auction or escrow logic within our contract that determines how players can trade / sell our zombies. If we conform to the spec, someone else could build an exchange platform for crypto-tradable ERC721 assets, and our ERC721 zombies would be usable on that platform. So there are clear benefits to using a token standard instead of rolling your own trading logic. . | The contract of ERC721 standard looks pretty much like an interface, waiting to be implemented: contract ERC721 { event Transfer(address indexed _from, address indexed _to, uint256 indexed _tokenId); event Approval(address indexed _owner, address indexed _approved, uint256 indexed _tokenId); function balanceOf(address _owner) external view returns (uint256); function ownerOf(uint256 _tokenId) external view returns (address); function transferFrom(address _from, address _to, uint256 _tokenId) external payable; function approve(address _approved, uint256 _tokenId) external payable; } . | In Solidity, we can inheirt from multiple contracts. . | To avoid overflows and underflows, we use the SafeMath library. A library is a special type of contract in Solidity. One of the things it is useful for is to attach functions to native data types. For example, with the SafeMath library, we‚Äôll use the syntax using SafeMath for uint256. The SafeMath library has 4 functions ‚Äî add, sub, mul, and div. And now we can access these functions from uint256 as follows: using SafeMath for uint256; uint256 a = 5; uint256 b = a.add(3); // 5 + 3 = 8 uint256 c = a.mul(2); // 5 * 2 = 10 . | assert is similar to require, where it will throw an error if false. The difference between assert and require is that require will refund the user the rest of their gas when a function fails, whereas assert will not. So most of the time you want to use require in your code; assert is typically used when something has gone horribly wrong with the code (like a uint overflow). . | The standard in the Solidity community is to use a format called natspec. | Also, thanks for Loom Network for bringing such awesome animations to us :D . . Solidity code from Lesson 5: . erc721.sol . pragma solidity &gt;=0.5.0 &lt;0.6.0; contract ERC721 { event Transfer(address indexed _from, address indexed _to, uint256 indexed _tokenId); event Approval(address indexed _owner, address indexed _approved, uint256 indexed _tokenId); function balanceOf(address _owner) external view returns (uint256); function ownerOf(uint256 _tokenId) external view returns (address); function transferFrom(address _from, address _to, uint256 _tokenId) external payable; function approve(address _approved, uint256 _tokenId) external payable; } . safemath.sol . pragma solidity &gt;=0.5.0 &lt;0.6.0; /** * @title SafeMath * @dev Math operations with safety checks that throw on error */ library SafeMath { /** * @dev Multiplies two numbers, throws on overflow. */ function mul(uint256 a, uint256 b) internal pure returns (uint256) { if (a == 0) { return 0; } uint256 c = a * b; assert(c / a == b); return c; } /** * @dev Integer division of two numbers, truncating the quotient. */ function div(uint256 a, uint256 b) internal pure returns (uint256) { // assert(b &gt; 0); // Solidity automatically throws when dividing by 0 uint256 c = a / b; // assert(a == b * c + a % b); // There is no case in which this doesn&#39;t hold return c; } /** * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend). */ function sub(uint256 a, uint256 b) internal pure returns (uint256) { assert(b &lt;= a); return a - b; } /** * @dev Adds two numbers, throws on overflow. */ function add(uint256 a, uint256 b) internal pure returns (uint256) { uint256 c = a + b; assert(c &gt;= a); return c; } } /** * @title SafeMath32 * @dev SafeMath library implemented for uint32 */ library SafeMath32 { function mul(uint32 a, uint32 b) internal pure returns (uint32) { if (a == 0) { return 0; } uint32 c = a * b; assert(c / a == b); return c; } function div(uint32 a, uint32 b) internal pure returns (uint32) { // assert(b &gt; 0); // Solidity automatically throws when dividing by 0 uint32 c = a / b; // assert(a == b * c + a % b); // There is no case in which this doesn&#39;t hold return c; } function sub(uint32 a, uint32 b) internal pure returns (uint32) { assert(b &lt;= a); return a - b; } function add(uint32 a, uint32 b) internal pure returns (uint32) { uint32 c = a + b; assert(c &gt;= a); return c; } } /** * @title SafeMath16 * @dev SafeMath library implemented for uint16 */ library SafeMath16 { function mul(uint16 a, uint16 b) internal pure returns (uint16) { if (a == 0) { return 0; } uint16 c = a * b; assert(c / a == b); return c; } function div(uint16 a, uint16 b) internal pure returns (uint16) { // assert(b &gt; 0); // Solidity automatically throws when dividing by 0 uint16 c = a / b; // assert(a == b * c + a % b); // There is no case in which this doesn&#39;t hold return c; } function sub(uint16 a, uint16 b) internal pure returns (uint16) { assert(b &lt;= a); return a - b; } function add(uint16 a, uint16 b) internal pure returns (uint16) { uint16 c = a + b; assert(c &gt;= a); return c; } } . zombieownership.sol . pragma solidity &gt;=0.5.0 &lt;0.6.0; import &quot;./zombieattack.sol&quot;; import &quot;./erc721.sol&quot;; import &quot;./safemath.sol&quot;; contract ZombieOwnership is ZombieAttack, ERC721 { using SafeMath for uint256; mapping (uint =&gt; address) zombieApprovals; function balanceOf(address _owner) external view returns (uint256) { return ownerZombieCount[_owner]; } function ownerOf(uint256 _tokenId) external view returns (address) { return zombieToOwner[_tokenId]; } function _transfer(address _from, address _to, uint256 _tokenId) private { ownerZombieCount[_to] = ownerZombieCount[_to].add(1); ownerZombieCount[msg.sender] = ownerZombieCount[msg.sender].sub(1); zombieToOwner[_tokenId] = _to; emit Transfer(_from, _to, _tokenId); } function transferFrom(address _from, address _to, uint256 _tokenId) external payable { require (zombieToOwner[_tokenId] == msg.sender || zombieApprovals[_tokenId] == msg.sender); _transfer(_from, _to, _tokenId); } function approve(address _approved, uint256 _tokenId) external payable onlyOwnerOf(_tokenId) { zombieApprovals[_tokenId] = _approved; emit Approval(msg.sender, _approved, _tokenId); } } . zombieattack.sol . pragma solidity &gt;=0.5.0 &lt;0.6.0; import &quot;./zombiehelper.sol&quot;; contract ZombieAttack is ZombieHelper { uint randNonce = 0; uint attackVictoryProbability = 70; function randMod(uint _modulus) internal returns(uint) { randNonce = randNonce.add(1); return uint(keccak256(abi.encodePacked(now, msg.sender, randNonce))) % _modulus; } function attack(uint _zombieId, uint _targetId) external onlyOwnerOf(_zombieId) { Zombie storage myZombie = zombies[_zombieId]; Zombie storage enemyZombie = zombies[_targetId]; uint rand = randMod(100); if (rand &lt;= attackVictoryProbability) { myZombie.winCount = myZombie.winCount.add(1); myZombie.level = myZombie.level.add(1); enemyZombie.lossCount = enemyZombie.lossCount.add(1); feedAndMultiply(_zombieId, enemyZombie.dna, &quot;zombie&quot;); } else { myZombie.lossCount = myZombie.lossCount.add(1); enemyZombie.winCount = enemyZombie.winCount.add(1); _triggerCooldown(myZombie); } } } . zombiefactory.sol . pragma solidity &gt;=0.5.0 &lt;0.6.0; import &quot;./ownable.sol&quot;; import &quot;./safemath.sol&quot;; contract ZombieFactory is Ownable { using SafeMath for uint256; using SafeMath32 for uint32; using SafeMath16 for uint16; event NewZombie(uint zombieId, string name, uint dna); uint dnaDigits = 16; uint dnaModulus = 10 ** dnaDigits; uint cooldownTime = 1 days; struct Zombie { string name; uint dna; uint32 level; uint32 readyTime; uint16 winCount; uint16 lossCount; } Zombie[] public zombies; mapping (uint =&gt; address) public zombieToOwner; mapping (address =&gt; uint) ownerZombieCount; function _createZombie(string memory _name, uint _dna) internal { uint id = zombies.push(Zombie(_name, _dna, 1, uint32(now + cooldownTime), 0, 0)) - 1; zombieToOwner[id] = msg.sender; ownerZombieCount[msg.sender] = ownerZombieCount[msg.sender].add(1); emit NewZombie(id, _name, _dna); } function _generateRandomDna(string memory _str) private view returns (uint) { uint rand = uint(keccak256(abi.encodePacked(_str))); return rand % dnaModulus; } function createRandomZombie(string memory _name) public { require(ownerZombieCount[msg.sender] == 0); uint randDna = _generateRandomDna(_name); randDna = randDna - randDna % 100; _createZombie(_name, randDna); } } . zombiefeeding.sol . pragma solidity &gt;=0.5.0 &lt;0.6.0; import &quot;./zombiefactory.sol&quot;; contract KittyInterface { function getKitty(uint256 _id) external view returns ( bool isGestating, bool isReady, uint256 cooldownIndex, uint256 nextActionAt, uint256 siringWithId, uint256 birthTime, uint256 matronId, uint256 sireId, uint256 generation, uint256 genes ); } contract ZombieFeeding is ZombieFactory { KittyInterface kittyContract; modifier onlyOwnerOf(uint _zombieId) { require(msg.sender == zombieToOwner[_zombieId]); _; } function setKittyContractAddress(address _address) external onlyOwner { kittyContract = KittyInterface(_address); } function _triggerCooldown(Zombie storage _zombie) internal { _zombie.readyTime = uint32(now + cooldownTime); } function _isReady(Zombie storage _zombie) internal view returns (bool) { return (_zombie.readyTime &lt;= now); } function feedAndMultiply(uint _zombieId, uint _targetDna, string memory _species) internal onlyOwnerOf(_zombieId) { Zombie storage myZombie = zombies[_zombieId]; require(_isReady(myZombie)); _targetDna = _targetDna % dnaModulus; uint newDna = (myZombie.dna + _targetDna) / 2; if (keccak256(abi.encodePacked(_species)) == keccak256(abi.encodePacked(&quot;kitty&quot;))) { newDna = newDna - newDna % 100 + 99; } _createZombie(&quot;NoName&quot;, newDna); _triggerCooldown(myZombie); } function feedOnKitty(uint _zombieId, uint _kittyId) public { uint kittyDna; (,,,,,,,,,kittyDna) = kittyContract.getKitty(_kittyId); feedAndMultiply(_zombieId, kittyDna, &quot;kitty&quot;); } } . zombiehelper.sol . pragma solidity &gt;=0.5.0 &lt;0.6.0; import &quot;./zombiefeeding.sol&quot;; contract ZombieHelper is ZombieFeeding { uint levelUpFee = 0.001 ether; modifier aboveLevel(uint _level, uint _zombieId) { require(zombies[_zombieId].level &gt;= _level); _; } function withdraw() external onlyOwner { address _owner = owner(); _owner.transfer(address(this).balance); } function setLevelUpFee(uint _fee) external onlyOwner { levelUpFee = _fee; } function levelUp(uint _zombieId) external payable { require(msg.value == levelUpFee); zombies[_zombieId].level = zombies[_zombieId].level.add(1); } function changeName(uint _zombieId, string calldata _newName) external aboveLevel(2, _zombieId) onlyOwnerOf(_zombieId) { zombies[_zombieId].name = _newName; } function changeDna(uint _zombieId, uint _newDna) external aboveLevel(20, _zombieId) onlyOwnerOf(_zombieId) { zombies[_zombieId].dna = _newDna; } function getZombiesByOwner(address _owner) external view returns(uint[] memory) { uint[] memory result = new uint[](ownerZombieCount[_owner]); uint counter = 0; for (uint i = 0; i &lt; zombies.length; i++) { if (zombieToOwner[i] == _owner) { result[counter] = i; counter++; } } return result; } } .",
            "url": "http://saxenism.com/web3/solidity/cryptozombies/beginner/2021/06/16/CryptoZombies-Lesson-5.html",
            "relUrl": "/web3/solidity/cryptozombies/beginner/2021/06/16/CryptoZombies-Lesson-5.html",
            "date": " ‚Ä¢ Jun 16, 2021"
        }
        
    
  
    
        ,"post4": {
            "title": "CryptoZombies - Lesson 4",
            "content": "Lesson 4: . view tells us that by running the functions, no data will be saved/changed. pure tells us that not only does the function not save any data to the blockchain, but it also doens‚Äôt read any data from the blockchain. Both of these don‚Äôt cost any gas to call if they‚Äôre called from outside the contract, but the do cost gas if called internally by another function because the calling function is eventually making changes on the blockchain. | The function modifiers can all be stacked together on a function definition, as follows: function test() external view onlyOwner anotherModifier { // Some function-y stuff } . | The payable modifier: They are a special type of functions that can recieve Ether. In Ethereum, because both the money (Ether), the data (transaction payload), and the contract code itself all live on Ethereum, it‚Äôs possible for you to call a function and pay money to the contract at the same time. This allows us to have some really cool logic, such as: requiring a certain payment to the contract in order to execute a function. Here‚Äôs an example: contract OnlineStore { function buySomething () external payable { require(msg.value == 0.01 ether); //ether is an inbuilt uint; transferStuff(msg.sender); } } . msg.value is a way to see how much Ether was sent to the contract. If a function is not marked as payable, and you try to send Ether to it, the function will reject your transaction. . | The payment can only be done to a data type that‚Äôs called address payable. Example: function withdraw() external onlyOwner() { address payable _owner = address(uint16(owner())); _owner.transfer(address(this).balance); } address(this).balance will return the total balance stored on the contract. . | A make-shift way of generating random numbers in Solidity is as follows: // Generate a random number between 1 and 100: uint randNonce = 0; uint random = uint(keccak256(abi.encodePacked(now, msg.sender, randNonce))) % 100; randNonce++; uint random2 = uint(keccak256(abi.encodePacked(now, msg.sender, randNonce))) % 100; . But, this is unsafe, because technically, this can be hacked. How? Read on: In Ethereum, when you call a function on a contract, you broadcast it to a node or nodes on the network as a transaction. The nodes on the network then collect a bunch of transactions, try to be the first to solve a computationally-intensive mathematical problem as a ‚ÄúProof of Work‚Äù, and then publish that group of transactions along with their Proof of Work (PoW) as a block to the rest of the network. Once a node has solved the PoW, the other nodes stop trying to solve the PoW, verify that the other node‚Äôs list of transactions are valid, and then accept the block and move on to trying to solve the next block. This makes our random number function exploitable. Let‚Äôs say we had a coin flip contract ‚Äîheads you double your money, tails you lose everything. Let‚Äôs say it used the above random function to determine heads or tails. (random &gt;= 50 is heads, random &lt; 50 is tails). If I were running a node, I could publish a transaction only to my own node and not share it. I could then run the coin flip function to see if I won ‚Äî and if I lost, choose not to include that transaction in the next block I‚Äôm solving. I could keep doing this indefinitely until I finally won the coin flip and solved the next block, and profit. . | One relatively safe method is to use an Oracle to access a random number from outside the Ethereum blockchain | . Solidity Code from Lesson 4 . zombieattack.sol . pragma solidity &gt;=0.5.0 &lt;0.6.0; import &quot;./zombiehelper.sol&quot;; contract ZombieAttack is ZombieHelper { uint randNonce = 0; uint attackVictoryProbability = 70; function randMod(uint _modulus) internal returns(uint) { randNonce++; return uint(keccak256(abi.encodePacked(now, msg.sender, randNonce))) % _modulus; } function attack(uint _zombieId, uint _targetId) external ownerOf(_zombieId) { Zombie storage myZombie = zombies[_zombieId]; Zombie storage enemyZombie = zombies[_targetId]; uint rand = randMod(100); if (rand &lt;= attackVictoryProbability) { myZombie.winCount++; myZombie.level++; enemyZombie.lossCount++; feedAndMultiply(_zombieId, enemyZombie.dna, &quot;zombie&quot;); } else { myZombie.lossCount++; enemyZombie.winCount++; _triggerCooldown(myZombie); } } } . zombiehelper.sol . pragma solidity &gt;=0.5.0 &lt;0.6.0; import &quot;./zombiefeeding.sol&quot;; contract ZombieHelper is ZombieFeeding { uint levelUpFee = 0.001 ether; modifier aboveLevel(uint _level, uint _zombieId) { require(zombies[_zombieId].level &gt;= _level); _; } function withdraw() external onlyOwner { address _owner = owner(); _owner.transfer(address(this).balance); } function setLevelUpFee(uint _fee) external onlyOwner { levelUpFee = _fee; } function levelUp(uint _zombieId) external payable { require(msg.value == levelUpFee); zombies[_zombieId].level++; } function changeName(uint _zombieId, string calldata _newName) external aboveLevel(2, _zombieId) ownerOf(_zombieId) { zombies[_zombieId].name = _newName; } function changeDna(uint _zombieId, uint _newDna) external aboveLevel(20, _zombieId) ownerOf(_zombieId) { zombies[_zombieId].dna = _newDna; } function getZombiesByOwner(address _owner) external view returns(uint[] memory) { uint[] memory result = new uint[](ownerZombieCount[_owner]); uint counter = 0; for (uint i = 0; i &lt; zombies.length; i++) { if (zombieToOwner[i] == _owner) { result[counter] = i; counter++; } } return result; } } . zombiefactory.sol . pragma solidity &gt;=0.5.0 &lt;0.6.0; import &quot;./ownable.sol&quot;; contract ZombieFactory is Ownable { event NewZombie(uint zombieId, string name, uint dna); uint dnaDigits = 16; uint dnaModulus = 10 ** dnaDigits; uint cooldownTime = 1 days; struct Zombie { string name; uint dna; uint32 level; uint32 readyTime; uint16 winCount; uint16 lossCount; } Zombie[] public zombies; mapping (uint =&gt; address) public zombieToOwner; mapping (address =&gt; uint) ownerZombieCount; function _createZombie(string memory _name, uint _dna) internal { uint id = zombies.push(Zombie(_name, _dna, 1, uint32(now + cooldownTime), 0, 0)) - 1; zombieToOwner[id] = msg.sender; ownerZombieCount[msg.sender]++; emit NewZombie(id, _name, _dna); } function _generateRandomDna(string memory _str) private view returns (uint) { uint rand = uint(keccak256(abi.encodePacked(_str))); return rand % dnaModulus; } function createRandomZombie(string memory _name) public { require(ownerZombieCount[msg.sender] == 0); uint randDna = _generateRandomDna(_name); randDna = randDna - randDna % 100; _createZombie(_name, randDna); } } . zombiefeeding.sol . pragma solidity &gt;=0.5.0 &lt;0.6.0; import &quot;./ownable.sol&quot;; contract ZombieFactory is Ownable { event NewZombie(uint zombieId, string name, uint dna); uint dnaDigits = 16; uint dnaModulus = 10 ** dnaDigits; uint cooldownTime = 1 days; struct Zombie { string name; uint dna; uint32 level; uint32 readyTime; uint16 winCount; uint16 lossCount; } Zombie[] public zombies; mapping (uint =&gt; address) public zombieToOwner; mapping (address =&gt; uint) ownerZombieCount; function _createZombie(string memory _name, uint _dna) internal { uint id = zombies.push(Zombie(_name, _dna, 1, uint32(now + cooldownTime), 0, 0)) - 1; zombieToOwner[id] = msg.sender; ownerZombieCount[msg.sender]++; emit NewZombie(id, _name, _dna); } function _generateRandomDna(string memory _str) private view returns (uint) { uint rand = uint(keccak256(abi.encodePacked(_str))); return rand % dnaModulus; } function createRandomZombie(string memory _name) public { require(ownerZombieCount[msg.sender] == 0); uint randDna = _generateRandomDna(_name); randDna = randDna - randDna % 100; _createZombie(_name, randDna); } } . ownable.sol . pragma solidity &gt;=0.5.0 &lt;0.6.0; /** * @title Ownable * @dev The Ownable contract has an owner address, and provides basic authorization control * functions, this simplifies the implementation of &quot;user permissions&quot;. */ contract Ownable { address private _owner; event OwnershipTransferred( address indexed previousOwner, address indexed newOwner ); /** * @dev The Ownable constructor sets the original `owner` of the contract to the sender * account. */ constructor() internal { _owner = msg.sender; emit OwnershipTransferred(address(0), _owner); } /** * @return the address of the owner. */ function owner() public view returns(address) { return _owner; } /** * @dev Throws if called by any account other than the owner. */ modifier onlyOwner() { require(isOwner()); _; } /** * @return true if `msg.sender` is the owner of the contract. */ function isOwner() public view returns(bool) { return msg.sender == _owner; } /** * @dev Allows the current owner to relinquish control of the contract. * @notice Renouncing to ownership will leave the contract without an owner. * It will not be possible to call the functions with the `onlyOwner` * modifier anymore. */ function renounceOwnership() public onlyOwner { emit OwnershipTransferred(_owner, address(0)); _owner = address(0); } /** * @dev Allows the current owner to transfer control of the contract to a newOwner. * @param newOwner The address to transfer ownership to. */ function transferOwnership(address newOwner) public onlyOwner { _transferOwnership(newOwner); } /** * @dev Transfers control of the contract to a newOwner. * @param newOwner The address to transfer ownership to. */ function _transferOwnership(address newOwner) internal { require(newOwner != address(0)); emit OwnershipTransferred(_owner, newOwner); _owner = newOwner; } } .",
            "url": "http://saxenism.com/web3/solidity/cryptozombies/beginner/2021/06/15/CryptoZombies-Lesson-4.html",
            "relUrl": "/web3/solidity/cryptozombies/beginner/2021/06/15/CryptoZombies-Lesson-4.html",
            "date": " ‚Ä¢ Jun 15, 2021"
        }
        
    
  
    
        ,"post5": {
            "title": "CryptoZombies - Lesson 3",
            "content": "Lesson 3: . After you deploy a contract to Ethereum, it is immutable. It can never be modified/updated again. For this reason, if often makes sense to have functions that will allow you to update key portions of your dApp | Ownable contract: Owners(contract creators) have special priviliges. It has the following three functions: a. When a contract is deployed, its constructor sets the owner to msg.sender (the person who deployed it) b. It adds an onlyOwner modifier, which can restirct access to certain functions to only the owner c. It allows you to transfer the contract to a new owner | Once you inherit from the Ownable contract, you can use the onlyOwner function modifier. This ensures that the function caller is indeed the contract owner or not | In Solidity, your users have to pay every time they execute a function on your DApp using a currency called gas. So, basically, users have to spend ETH in order to execute functions on your DApp. | How much gas is required to execute a function depends on how complex that function‚Äôs logic is. Each individual operation has a gas cost based roughly on how much computing resources will be required to perform that operation. The total gas cost of your function is the sum of the gas costs of all its individual operations. Therefore, code optimization is much much more important in Ethereum than in other programming languages. Because, if your code is slopp, then your users are going to pay a premium to execute your functions ‚Äì and this could add up to millions of dollars in unnecessary fees across thousand of users. | Choosing either of uint8, uint16, uint32, uint256 will result in the same gas fee because Ethereum reserves the same space for each, irrespective of what uint you choose. But you can save on costs when working with multiple uints inside of a struct. Also, for this to happen, you would want to cluster identical data types together (ie put them next to each other in the struct) | Solidity provides some native units for dealing with time. The variable now will return the current unix timestamp of the latest block (the number of seconds that have passed since January 1st 1970). Solidity also contains the time units seconds, minutes, hours, days, weeks and years. | We can pass a storage pointer to a struct as an argument to a private or internal function. | An important security practice is to examine all your public and external functions, and try to think of ways users might abuse them. Because, unless these functions have a modifier like onlyOwner, any user can call them and pass them any data they want to. | The custom function modifier (like onlyOwner) can also take some parameters. The following example will clear things up: mapping (uint =&gt; uint) public age; // Modifier that requires this user to be older than a certain age: modifier olderThan(uint _age, uint _userId) { require(age[_userId] &gt;= _age); _; } function driveCar(uint _userId) public olderThan(16, _userId) { // Some function logic } . | Remember how we used memory pointer type along with string in function parameters. Similar to memory we have calldata but it‚Äôs only available to external functions | Since view functions only needs to query your local Ethereum node to run the function, it doesn‚Äôt actually have to create a transaction on the blockchain, which would need to run on every single node, and cost gas. Therefore, view functions don‚Äôt cost any gas when they‚Äôre called externally by a user. Optimize your DApp‚Äôs gas usage for your users by using read-only external view functions wherever possible. If a view function is called internally from another function in the same contract that is not a view function, it will still cost gas. This is because the other function creates a transaction on Ethereum, and will still need to be verified from every node. So view functions are only free when they‚Äôre called externally. | One of the more expensive operations in Solidity is using storage ‚Äî particularly writes. This is because every time you write or change a piece of data, it‚Äôs written permanently to the blockchain. Forever! Thousands of nodes across the world need to store that data on their hard drives, and this amount of data keeps growing over time as the blockchain grows. So there‚Äôs a cost to doing that. In order to keep costs down, you want to avoid writing data to storage except when absolutely necessary. Sometimes this involves seemingly inefficient programming logic ‚Äî like rebuilding an array in memory every time a function is called instead of simply saving that array in a variable for quick lookups. In most programming languages, looping over large data sets is expensive. But in Solidity, this is way cheaper than using storage if it‚Äôs in an external view function, since view functions don‚Äôt cost your users any gas. (And gas costs your users real money!). An example illustrating how to declare arrays in memory: function getArray() external pure returns(uint[] memory) { // Instantiate a new array in memory with a length of 3 uint[] memory values = new uint[](3); // Put some values to it values[0] = 1; values[1] = 2; values[2] = 3; return values; } . | for loops will be preferred over mapping solutions, if it can save gas cost. | . Solidity Code from Lesson 3: . ##ownable.sol . pragma solidity &gt;=0.5.0 &lt;0.6.0; /** * @title Ownable * @dev The Ownable contract has an owner address, and provides basic authorization control * functions, this simplifies the implementation of &quot;user permissions&quot;. */ contract Ownable { address private _owner; event OwnershipTransferred( address indexed previousOwner, address indexed newOwner ); /** * @dev The Ownable constructor sets the original `owner` of the contract to the sender * account. */ constructor() internal { _owner = msg.sender; emit OwnershipTransferred(address(0), _owner); } /** * @return the address of the owner. */ function owner() public view returns(address) { return _owner; } /** * @dev Throws if called by any account other than the owner. */ modifier onlyOwner() { require(isOwner()); _; } /** * @return true if `msg.sender` is the owner of the contract. */ function isOwner() public view returns(bool) { return msg.sender == _owner; } /** * @dev Allows the current owner to relinquish control of the contract. * @notice Renouncing to ownership will leave the contract without an owner. * It will not be possible to call the functions with the `onlyOwner` * modifier anymore. */ function renounceOwnership() public onlyOwner { emit OwnershipTransferred(_owner, address(0)); _owner = address(0); } /** * @dev Allows the current owner to transfer control of the contract to a newOwner. * @param newOwner The address to transfer ownership to. */ function transferOwnership(address newOwner) public onlyOwner { _transferOwnership(newOwner); } /** * @dev Transfers control of the contract to a newOwner. * @param newOwner The address to transfer ownership to. */ function _transferOwnership(address newOwner) internal { require(newOwner != address(0)); emit OwnershipTransferred(_owner, newOwner); _owner = newOwner; } } . zombiefactory.sol . pragma solidity &gt;=0.5.0 &lt;0.6.0; import &quot;./ownable.sol&quot;; contract ZombieFactory is Ownable { event NewZombie(uint zombieId, string name, uint dna); uint dnaDigits = 16; uint dnaModulus = 10 ** dnaDigits; uint cooldownTime = 1 days; struct Zombie { string name; uint dna; uint32 level; uint32 readyTime; } Zombie[] public zombies; mapping (uint =&gt; address) public zombieToOwner; mapping (address =&gt; uint) ownerZombieCount; function _createZombie(string memory _name, uint _dna) internal { uint id = zombies.push(Zombie(_name, _dna, 1, uint32(now + cooldownTime))) - 1; zombieToOwner[id] = msg.sender; ownerZombieCount[msg.sender]++; emit NewZombie(id, _name, _dna); } function _generateRandomDna(string memory _str) private view returns (uint) { uint rand = uint(keccak256(abi.encodePacked(_str))); return rand % dnaModulus; } function createRandomZombie(string memory _name) public { require(ownerZombieCount[msg.sender] == 0); uint randDna = _generateRandomDna(_name); randDna = randDna - randDna % 100; _createZombie(_name, randDna); } } . zombiefeeding.sol . pragma solidity &gt;=0.5.0 &lt;0.6.0; import &quot;./zombiefactory.sol&quot;; contract KittyInterface { function getKitty(uint256 _id) external view returns ( bool isGestating, bool isReady, uint256 cooldownIndex, uint256 nextActionAt, uint256 siringWithId, uint256 birthTime, uint256 matronId, uint256 sireId, uint256 generation, uint256 genes ); } contract ZombieFeeding is ZombieFactory { KittyInterface kittyContract; function setKittyContractAddress(address _address) external onlyOwner { kittyContract = KittyInterface(_address); } function _triggerCooldown(Zombie storage _zombie) internal { _zombie.readyTime = uint32(now + cooldownTime); } function _isReady(Zombie storage _zombie) internal view returns (bool) { return (_zombie.readyTime &lt;= now); } function feedAndMultiply(uint _zombieId, uint _targetDna, string memory _species) internal { require(msg.sender == zombieToOwner[_zombieId]); Zombie storage myZombie = zombies[_zombieId]; require(_isReady(myZombie)); _targetDna = _targetDna % dnaModulus; uint newDna = (myZombie.dna + _targetDna) / 2; if (keccak256(abi.encodePacked(_species)) == keccak256(abi.encodePacked(&quot;kitty&quot;))) { newDna = newDna - newDna % 100 + 99; } _createZombie(&quot;NoName&quot;, newDna); _triggerCooldown(myZombie); } function feedOnKitty(uint _zombieId, uint _kittyId) public { uint kittyDna; (,,,,,,,,,kittyDna) = kittyContract.getKitty(_kittyId); feedAndMultiply(_zombieId, kittyDna, &quot;kitty&quot;); } } . zombiehelper.sol . pragma solidity &gt;=0.5.0 &lt;0.6.0; import &quot;./zombiefeeding.sol&quot;; contract ZombieHelper is ZombieFeeding { // 1. Define levelUpFee here modifier aboveLevel(uint _level, uint _zombieId) { require(zombies[_zombieId].level &gt;= _level); _; } // 2. Insert levelUp function here function changeName(uint _zombieId, string calldata _newName) external aboveLevel(2, _zombieId) { require(msg.sender == zombieToOwner[_zombieId]); zombies[_zombieId].name = _newName; } function changeDna(uint _zombieId, uint _newDna) external aboveLevel(20, _zombieId) { require(msg.sender == zombieToOwner[_zombieId]); zombies[_zombieId].dna = _newDna; } function getZombiesByOwner(address _owner) external view returns(uint[] memory) { uint[] memory result = new uint[](ownerZombieCount[_owner]); uint counter = 0; for (uint i = 0; i &lt; zombies.length; i++) { if (zombieToOwner[i] == _owner) { result[counter] = i; counter++; } } return result; } } .",
            "url": "http://saxenism.com/web3/solidity/cryptozombies/beginner/2021/06/14/CryptoZombies-Lesson-3.html",
            "relUrl": "/web3/solidity/cryptozombies/beginner/2021/06/14/CryptoZombies-Lesson-3.html",
            "date": " ‚Ä¢ Jun 14, 2021"
        }
        
    
  
    
        ,"post6": {
            "title": "CryptoZombies - Lesson 2",
            "content": "Lesson 2: . Addresses: The ethereum blockchain is made up of accounts, which you can think of as bank accounts. An account has a balance of Ether, and you can send and recieve Ether payments to other accounts, just like your bank account can wire transfer money to other bank accounts Each bank account has an address which you can think of like a bank account number.Its a unique identifier that points to an account. An address is owned by a specific user or a smart contract. Mapping: So we can use it as a unique ID for ownership of our zombies. When a user creates new zombies by interacting with our app, we‚Äôll set ownership of those zombies to the Ethereum address that called the function A mapping is essentially a key-value store for storing and looking up data mapping(uint =&gt; string) userIdToName; | msg.sender In solidity, there are certain global variables that are available to all functions. One of them is msg.sender msg.sender refers to the address of the person (or the smart contract) who called the current function In solidity, function execution always needs to start with an external caller. A contract will just sit on the blockchain doing nothing until someone calls one of its functions. So, there will always be a msg.sender | require is a keyword in Solidity used for condition checking. If this condition is met, then only a function is executed otherwise, it terminates with an error. Example: function sayHiToVitalik (string memory _name) public returns (string memory) { require(keccak256(abi.encodePacked(_name)) == keccak256(abi.encodePacked(&quot;Vitalik&quot;))); return &quot;Hi Vitalik, thank you for Ethereum!!&quot;; } . | Solidity does not support string comparison natively, so we simply compare the keccak256 hashes of the two strings. | Solidity supports inheritence. Hence, instead of writing one big long contract, it makes sense to split your code logic across multiple contracts to organize the code. | Really cool and succint inheritence syntax: contract cat is animal { } // Here the contract cat inherits from the contract animal :D . | Syntax to import one file into another: import &#39;./someOtherContract.sol&#39;; contract newContract is someOtherContract { } . | In solidity, there are two locations in which you can store variables - in storage and in memory. Storage refers to variables permanently stored on the blockchain. Memory variables are temporary, and are erased between external function calls to your contract. Think of it like a computer‚Äôs Hard Disk vs RAM Example: contract SandwichFactory { struct Sandwich { string name; string status; } Sandwich[] sandwiches; function eatSandwich(uint _index) public { // Sandwich mySandwich = sandwiches[_index]; // ^ Seems pretty straightforward, but solidity will give you a warning // telling you that you should explicitly declare storage or memory here. // So instead, you should declare with the storage keyword, like: Sandwich storage mySandwich = sandwiches[_index]; // ...in which case mySandwich is a pointer to sandwiches[_index] // in storage, and... mySandwich.status = &quot;Eaten!&quot;; // ...this will permanently change `sandwiches[_index]` on the blockchain. // If you just want a copy, you can use memory: Sandwich memory anotherSandwich = sandwiches[_index + 1]; // ...in which case anotherSandwich will simply be a copy of the // data in memory, and... anotherSandwich.status = &quot;Eaten!&quot;; // ...will just modify the temporary variable and have no effect // on sandwiches[_index + 1]. But you can do this: sandwiches[_index + 1] = anotherSandwich; // ...if you want to copy the changes back into blockchain storage. } } . | For a struct People such as: struct People { string name; uint age; } People randomMan = People(&quot;Sam&quot;, &quot;22&quot;); . You can access the properties of this struct as follows: randomMan.age or randomMan.name . | Types of functions in solidity: a. Private b. Internal c. Public d. External internal is the same as private, except that it‚Äôs also accessible to contracts that inherit from this contract. external is the same public, except that these functions can ONLY be called outside the contract. | Interacting with other smart contracts on the Ethereum blockchain: a. Define an interface (almost the same syntax as that of a contract, but only function signatures are mentioned here.) b. Only those function signatures need to be written in the interface, that we actually need to call c. Grab the address of the smart contract, you want to call the function from d. Initialise the interface you built with this address (much like creating an object) e. Example: contract NumberInterface { function getNum(address _myAddress) public view returns (uint); } contract MyContract { address NumberInterfaceAddress = 0xabcde122...... NumberInterface numberContract = NumberInterface(NumberInterfaceAddress); function someFunction() public { uint num = numberContract.getNum(msg.sender); } } . | In Solidity you can return more than one value from a function :D | This example illustrates, how we manage multiple return values from Solidity function: function multipleReturns() internal returns(uint a, uint b, uint c) { return (1, 2, 3); } function processMultipleReturns() external { uint a; uint b; uint c; // This is how you do multiple assignment: (a, b, c) = multipleReturns(); } // Or if we only cared about one of the values: function getLastReturnValue() external { uint c; // We can just leave the other fields blank: (,,c) = multipleReturns(); } . . | Solidity code from Lesson2 . zombiefactory.sol . pragma solidity &gt;= 0.8.4; contract ZombieFactory { event NewZombie(uint zombieId, string name, uint dna); uint dnaDigits = 16; uint dnaModulus = 10 ** dnaDigits; //(10^16) struct Zombie { string name; uint dna; } Zombie[] public zombies; mapping (uint =&gt; address) public zombieToOwner; mapping (address =&gt; uint) ownerZombieCount; function _createZombie(string memory _name, uint _dna) internal { zombies.push(Zombie(_name, _dna)); uint id = zombies.length - 1; zombieToOwner[id] = msg.sender; ownerZombieCount[msg.sender]++; emit NewZombie(id, _name, _dna); } function _generateRandomDna(string memory _str) private view returns (uint) { uint rand = uint(keccak256(abi.encodePacked(_str))); return rand % dnaModulus; } function createRandomZombie(string memory _name) public { require(ownerZombieCount[msg.sender] == 0); uint randDna = _generateRandomDna(_name); randDna = randDna - randDna % 100; _createZombie(_name, randDna); } } . zombiefeeding.sol . pragma solidity ^ 0.8.4; import &quot;lesson2_zombiefactory.sol&quot;; contract KittyInterface { function getKitty(uint256 _id) external view returns ( bool isGestating, bool isReady, uint256 cooldownIndex, uint256 nextActionAt, uint256 siringWithId, uint256 birthTime, uint256 matronId, uint256 sireId, uint256 generation, uint256 genes ); } contract ZombieFeeding is ZombieFactory { address ckAddress = 0x06012c8cf97BEaD5deAe237070F9587f8E7A266d; KittyInterface kittyContract = KittyInterface(ckAddress); function feedAndMultiply(uint _zombieId, uint _targetDna, string memory _species) public { require(msg.sender == zombieToOwner[_zombieId]); Zombie storage myZombie = zombies[_zombieId]; _targetDna = _targetDna % dnaModulus; uint newDna = (myZombie.dna + _targetDna) / 2; if (keccak256(abi.encodePacked(_species)) == keccak256(abi.encodePacked(&quot;kitty&quot;))) { newDna = newDna - newDna % 100 + 99; } _createZombie(&quot;NoName&quot;, newDna); } function feedOnKitty(uint _zombieId, uint _kittyId) public { uint kittyDna; (,,,,,,,,,kittyDna) = kittyContract.getKitty(_kittyId); feedAndMultiply(_zombieId, kittyDna, &quot;kitty&quot;); } } .",
            "url": "http://saxenism.com/web3/solidity/cryptozombies/beginner/2021/06/13/CryptoZombies-Lesson-2.html",
            "relUrl": "/web3/solidity/cryptozombies/beginner/2021/06/13/CryptoZombies-Lesson-2.html",
            "date": " ‚Ä¢ Jun 13, 2021"
        }
        
    
  
    
        ,"post7": {
            "title": "CryptoZombies - Lesson 1",
            "content": "Lesson 1: . Solidity code is encapsulated in contracts. A contract is the fundamental building block of Ethereum applications. All variables and functions belong to a contract and this will be the starting point of all projects | State Variables: Permanently stored in contract storage (they are written to the Ethereum Blockchain) Think of declaring state variables like writing to a DB | Arithmetic operations: x+y, x-y, x*y, x/y, x%y, x**y(same as x^y) | structs struct Person { uint age; string name; } . | Arrays {Possible to create an array of structs as well as native data types} Fixed arrays -&gt; uint [2] fixedArr Dynamic arrays -&gt; uint [] dynamicArr If an array is declared as public, other contracts can read from but not write to this array | function createZombies (string memory _name, uint _dna) public { underscore is a naming convention to separate the private variables from the global variables(_name) } . Notice the word memory along with the string parameter, it signifies that _name would be memory and not in stack, therefore would not be written to the blockchain, hence cheaper The memory keyword is required for reference type varialbles: arrays, structs, mapping, strings, etc. . | Pushing to the array: Person Satoshi = Person(172, &quot;Satoshi&quot;); people.push(Satoshi); . | In solidity, all functions are public by default. Good practice is to intially make all the functions private and then only make public the functions you want to expost to the world Convetion to start private functions with underscore (function _generateZombieID()) | Return values function sayHello() public returns (string memory) { } . If a function does not change any values, we can term it as a view function. [function sayHello() public view returns (string memory) {}] Pure functions =&gt; not accessing any data from the contract. . | Keccak256 and typecasting: Ethereum has the hash function keccak 256 built-in, which is a version of SHA3. keccak256 expects a single parameter of type bytes This means we have to ‚Äúpack‚Äù any parameter before calling keccak256 | Compiler supports typecasting var = uint8(var) =&gt; This shit | Events are a way for your contract to communicate to your app front-end that something has happened on the blockchain, which can be listening for certain events and take actions when they happen Example declaration: event IntegersAdded(uint x, uint y, uint result); //Include input and ouputs to a function function add(uint _x, uint _y) public returns (uint) { uint result = _x + _y; emit IntegersAdded(_x, _y, result); return result; } . | . Solidity code from Lesson 1 . pragma solidity ^ 0.8.0; contract ZombieWorld { event NewZomie(uint zombieId, string name, uint dna); uint dnaDigits = 16; uint dnaModulus = 10 ** dnaDigits; struct Zombie { string name; uint dna; } Zombie[] public zombies; function _createZombie(string memory _name, uint _dna) private { zombies.push(Zombie(_name, _dna)); uint id = zombies.length - 1; emit NewZomie(id, _name, _dna); } function _generateRandomDna(string memory _str) private view returns (uint) { uint rand = uint(keccak256(abi.encodePacked(_str))); return rand % dnaModulus; } function createRandomZombie(string memory _name) public { uint randDna = _generateRandomDna(_name); _createZombie(_name, randDna); } } .",
            "url": "http://saxenism.com/web3/solidity/cryptozombies/beginner/2021/06/12/Cryptozombies-Lesson-1.html",
            "relUrl": "/web3/solidity/cryptozombies/beginner/2021/06/12/Cryptozombies-Lesson-1.html",
            "date": " ‚Ä¢ Jun 12, 2021"
        }
        
    
  
    
        ,"post8": {
            "title": "An Example Markdown Post",
            "content": "Example Markdown Post . Basic setup . Jekyll requires blog post files to be named according to the following format: . YEAR-MONTH-DAY-filename.md . Where YEAR is a four-digit number, MONTH and DAY are both two-digit numbers, and filename is whatever file name you choose, to remind yourself what this post is about. .md is the file extension for markdown files. . The first line of the file should start with a single hash character, then a space, then your title. This is how you create a ‚Äúlevel 1 heading‚Äù in markdown. Then you can create level 2, 3, etc headings as you wish but repeating the hash character, such as you see in the line ## File names above. . Basic formatting . You can use italics, bold, code font text, and create links. Here‚Äôs a footnote 1. Here‚Äôs a horizontal rule: . . Lists . Here‚Äôs a list: . item 1 | item 2 | . And a numbered list: . item 1 | item 2 | Boxes and stuff . This is a quotation . . You can include alert boxes ‚Ä¶and‚Ä¶ . . You can include info boxes Images . . Code . You can format text and code per usual . General preformatted text: . # Do a thing do_thing() . Python code and output: . # Prints &#39;2&#39; print(1+1) . 2 . Formatting text as shell commands: . echo &quot;hello world&quot; ./some_script.sh --option &quot;value&quot; wget https://example.com/cat_photo1.png . Formatting text as YAML: . key: value - another_key: &quot;another value&quot; . Tables . Column 1 Column 2 . A thing | Another thing | . Tweetcards . Altair 4.0 is released! https://t.co/PCyrIOTcvvTry it with: pip install -U altairThe full list of changes is at https://t.co/roXmzcsT58 ...read on for some highlights. pic.twitter.com/vWJ0ZveKbZ . &mdash; Jake VanderPlas (@jakevdp) December 11, 2019 Footnotes . This is the footnote.¬†&#8617; . |",
            "url": "http://saxenism.com/markdown/2020/01/14/test-markdown-post.html",
            "relUrl": "/markdown/2020/01/14/test-markdown-post.html",
            "date": " ‚Ä¢ Jan 14, 2020"
        }
        
    
  

  
  

  
      ,"page1": {
          "title": "About Me",
          "content": "This website is powered by fastpages 1. . a blogging platform that natively supports Jupyter notebooks in addition to other formats.¬†&#8617; . |",
          "url": "http://saxenism.com/about/",
          "relUrl": "/about/",
          "date": ""
      }
      
  

  

  
  

  

  
  

  

  
  

  
  

  
  

  
      ,"page10": {
          "title": "",
          "content": "Sitemap: {{ ‚Äúsitemap.xml‚Äù | absolute_url }} | .",
          "url": "http://saxenism.com/robots.txt",
          "relUrl": "/robots.txt",
          "date": ""
      }
      
  

}