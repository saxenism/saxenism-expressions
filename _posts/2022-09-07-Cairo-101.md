---
toc: true
layout: post
description: First impressions about StarkNet and Cairo
categories: [web3, cairo, starknet, beginner]
title: Intro to StarkNet
---

## ASIC to CPU

1. ASIC (Application Specific Integrated Circuits) are specialized, fast, expensive and very hard to design.

2. CPUs are general purpose, slower, cheaper and easier to program for. A single architecture for multiple purposes.

3. Choosing between ASIC and CPU is a case between *efficiency vs flexibility*

## STARK

1. STARK is a family of cryptographic proof systems that can be used for privacy and scalability.
 
2. STARK proves statments, saying that a computation was executed correctly.

3. Examples for provable statements:

    3.1. The 1000th number in the Fibonacci sequence is X.
    3.2. I have 100 signed bank txns that are valid

4. Starkware/Starknet focuses on scalability instead of privacy and the primary focus is to reduce the verification time as much as possible.

## What is StarkNet

StarkNet is a permissionless decentralized Validity-rollup (ZK-Rollup). It operates as an L2 network over Ethereum, enabling any dApp to achieve unlimited scale for its computation - without compromising Ethereum's composability and security (thanks to STARK).

StarkNet contracts and the StarkNet OS are written in Cairo - supporting the deployment and scaling of any use case, whatever the business logic.

## Wallets on StarkNet

In StarkNet there is only one type of accounts - smart contract accounts (this is called Account Abstraction), in contrast to Ethereum where there are wallets and smart contracts. Therefore, every wallet on StarkNet is a smart contract and there is no distinction between them and other smart contracts.

Therefore, to create a new wallet, you need to deploy a transaction that publishes your smart contract wallet to the network.


## Validity Proofs (StarkNet, zkSync)

ZK Proofs == Validity Proofs

A novel piece of cryptography lets you collapse quite a bit of computation into a small easily verifiable proof, called zero knowledge proofs.

So, in a network there are a few big computers, doing the heavy lifting of actually doing all the computations, but all the other people in the network with smaller computers have the means to verify the work done by the big computer miners via Zk.

Zk proofs assure you, that some computation was done correctly, without you having to do all the computations.

Basically you have mathematical guarentee that the big computers/miners are working as expected.

> And, the beautiful thing about this is that these proofs can be verified by Ethereum too.

## Proofs

Think of proofs as a new cryptographic primitive where a prover can present his *proof* for having spent certain resources for doing certain amount of computations.

Basic Assumption for proofs, and for validity proofs to be considered legitimate is that:

*Time(proof verification) < Time(underlying program execution)*

Ethereum can natively understand the zk-proofs generated by the prover.

There is no middle man between Starknet and Ethereum.

## The case of Middle Men

*How do you get to use BTC on the ETH chain ?*

You give your BTC to **BitGo** and they give you equivalent ERC20 tokens of WBTC (minus some fee).

In this process, there is a huge human component involved. Humans have to do the translation between chains.

Most L1's and bridges work this way.

Yes, we do have certain incentives for those humans to not cheat. However, with this primitive (proofs) we do not need humans whatsoever.

## Awesomeness of ZKP (Recursions)

Size of proofs increase logarithmically with the number of computations. 

### Recursion: A Thought Experiment

Soon enough, what you'll be able to do is start a StarkNet instance, do some computations and send the proof to another StarkNet instance which is 1 layer below it, to verify the proof.

That lower instance again does it's own computations and creates a new proof from the proof it recieved + it's own computations and then sends this new proof one layer down.

This keeps on happening until eventually the proofs reach the underlying L1 with a single proof of a fuck-ton of computations.

> Ethereum verifying the proofs sent over has nothing to do with PoW. The verification is done banking on the EVM's ability to process and run opcodes. So, if Ethereum uses PoW or PoS or anything else going into the future, as long as EVM can process opcodes, it can verify zk-proofs

### Calculations

StarkNet so good at calculations, you could run entire game engines on top of it. Case in point is the recursion that we just discussed. Kinda makes on-chain  computation infinitely scalable.

Do not assume privacy from StarkNet. Because the txn block you send would be visible in clear. Only advantage here is that you do not need to repeat all computations to verify all computations.

## Stark vs Snark

Stark prover is way more efficient (faster) than Snark. Snark beats Stark in other areas, but proving time is the criterion with which StartNet moves ahead.

## Cairo

Cairo is a turing-complete language (a language that has overcome the halting problem) that developer can use to leverage the power of STARKs.

Cairo does not have any circuits associated with it.

The Cairo CPU is quite different than your regular x86 in the sense that your x86 is very good at logical operations but bad at division, the case is inverted in case of Cairo CPU.

Cairo helps you program non-determinism into your program (I do not understand what that means. Yet.)

## First lines of Cairo

```cairo
# fun with cairo

func sqr(a) -> (a):
    return (a = a * a)
end

func add_num_square(x, y) -> (x):
    let a = x + y
    let (z) = sqr(a = a)
    return (x = z)
end

func main():
    let (x) = add_num_square(x = 1, y = 3)
    assert x = 16
    return ()
end

```