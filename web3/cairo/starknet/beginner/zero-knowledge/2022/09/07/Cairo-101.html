<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="twitter:card" content="summary_large_image" /><!-- Begin Jekyll SEO tag v2.8.0 -->
<title>Intro to StarkNet | EVM Expressions</title>
<meta name="generator" content="Jekyll v4.1.1" />
<meta property="og:title" content="Intro to StarkNet" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="First impressions about StarkNet and Cairo" />
<meta property="og:description" content="First impressions about StarkNet and Cairo" />
<link rel="canonical" href="https://saxenism.com/web3/cairo/starknet/beginner/zero-knowledge/2022/09/07/Cairo-101.html" />
<meta property="og:url" content="https://saxenism.com/web3/cairo/starknet/beginner/zero-knowledge/2022/09/07/Cairo-101.html" />
<meta property="og:site_name" content="EVM Expressions" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2022-09-07T00:00:00-05:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="Intro to StarkNet" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2022-09-07T00:00:00-05:00","datePublished":"2022-09-07T00:00:00-05:00","description":"First impressions about StarkNet and Cairo","headline":"Intro to StarkNet","mainEntityOfPage":{"@type":"WebPage","@id":"https://saxenism.com/web3/cairo/starknet/beginner/zero-knowledge/2022/09/07/Cairo-101.html"},"url":"https://saxenism.com/web3/cairo/starknet/beginner/zero-knowledge/2022/09/07/Cairo-101.html"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/assets/css/style.css"><link type="application/atom+xml" rel="alternate" href="https://saxenism.com/feed.xml" title="EVM Expressions" /><!-- the google_analytics_id gets auto inserted from the config file -->



<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-NCLWFTBNXB"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-NCLWFTBNXB');
</script>


<link rel="shortcut icon" type="image/x-icon" href="/images/favicon.ico"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/Primer/15.2.0/primer.css" integrity="sha512-xTz2ys4coGAOz8vuV1NcQBkgVmKhsSEtjbqyMJbBHRplFuvKIUo6xhLHpAyPt9mfR6twHJgn9OgVLuqOvjeBhg==" crossorigin="anonymous" />
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.14.0/css/all.min.css" integrity="sha512-1PKOgIY59xJ8Co8+NE6FZ+LOAZKjy+KY8iq0G4B3CyeY6wYHN3yt9PW0XpSriVlkMXe40PTKnXrLnZ9+fkDaog==" crossorigin="anonymous" />

<script>
function wrap_img(fn) {
    if (document.attachEvent ? document.readyState === "complete" : document.readyState !== "loading") {
        var elements = document.querySelectorAll(".post img");
        Array.prototype.forEach.call(elements, function(el, i) {
            if (el.getAttribute("title") && (el.className != "emoji")) {
                const caption = document.createElement('figcaption');
                var node = document.createTextNode(el.getAttribute("title"));
                caption.appendChild(node);
                const wrapper = document.createElement('figure');
                wrapper.className = 'image';
                el.parentNode.insertBefore(wrapper, el);
                el.parentNode.removeChild(el);
                wrapper.appendChild(el);
                wrapper.appendChild(caption);
            }
        });
    } else { document.addEventListener('DOMContentLoaded', fn); }
}
window.onload = wrap_img;
</script>

<script>
    document.addEventListener("DOMContentLoaded", function(){
    // add link icon to anchor tags
    var elem = document.querySelectorAll(".anchor-link")
    elem.forEach(e => (e.innerHTML = '<i class="fas fa-link fa-xs"></i>'));
    });
</script>
</head>
<body><header class="site-header">

  <div class="wrapper"><a class="site-title" rel="author" href="/">EVM Expressions</a><nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>

        <div class="trigger"><a class="page-link" href="/about/">About Me</a><a class="page-link" href="/search/">Search</a><a class="page-link" href="/categories/">Tags</a></div>
      </nav></div>
</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title p-name" itemprop="name headline">Intro to StarkNet</h1><p class="page-description">First impressions about StarkNet and Cairo</p><p class="post-meta post-meta-title"><time class="dt-published" datetime="2022-09-07T00:00:00-05:00" itemprop="datePublished">
        Sep 7, 2022
      </time>
       • <span class="read-time" title="Estimated read time">
    
    
      11 min read
    
</span></p>

    
      <p class="category-tags"><i class="fas fa-tags category-tags-icon"></i></i> 
      
        <a class="category-tags-link" href="/categories/#web3">web3</a>
        &nbsp;
      
        <a class="category-tags-link" href="/categories/#cairo">cairo</a>
        &nbsp;
      
        <a class="category-tags-link" href="/categories/#starknet">starknet</a>
        &nbsp;
      
        <a class="category-tags-link" href="/categories/#beginner">beginner</a>
        &nbsp;
      
        <a class="category-tags-link" href="/categories/#zero-knowledge">zero-knowledge</a>
        
      
      </p>
    

    </header>

  <div class="post-content e-content" itemprop="articleBody">
    <ul id="toc" class="section-nav">
<li class="toc-entry toc-h2"><a href="#asic-to-cpu">ASIC to CPU</a></li>
<li class="toc-entry toc-h2"><a href="#stark">STARK</a></li>
<li class="toc-entry toc-h2"><a href="#what-is-starknet">What is StarkNet</a></li>
<li class="toc-entry toc-h2"><a href="#wallets-on-starknet">Wallets on StarkNet</a></li>
<li class="toc-entry toc-h2"><a href="#validity-proofs-starknet-zksync">Validity Proofs (StarkNet, zkSync)</a></li>
<li class="toc-entry toc-h2"><a href="#proofs">Proofs</a></li>
<li class="toc-entry toc-h2"><a href="#the-case-of-middle-men">The case of Middle Men</a></li>
<li class="toc-entry toc-h2"><a href="#awesomeness-of-zkp-recursions">Awesomeness of ZKP (Recursions)</a>
<ul>
<li class="toc-entry toc-h3"><a href="#recursion-a-thought-experiment">Recursion: A Thought Experiment</a></li>
<li class="toc-entry toc-h3"><a href="#calculations">Calculations</a></li>
</ul>
</li>
<li class="toc-entry toc-h2"><a href="#stark-vs-snark">Stark vs Snark</a></li>
<li class="toc-entry toc-h2"><a href="#cairo">Cairo</a>
<ul>
<li class="toc-entry toc-h3"><a href="#from-the-documentation">From the documentation</a></li>
</ul>
</li>
<li class="toc-entry toc-h2"><a href="#first-lines-of-cairo">First lines of Cairo</a>
<ul>
<li class="toc-entry toc-h3"><a href="#sum-of-all-elements-of-an-array">Sum of all elements of an array</a></li>
<li class="toc-entry toc-h3"><a href="#product-of-all-even-entries-of-the-array">Product of all even entries of the array</a></li>
</ul>
</li>
<li class="toc-entry toc-h2"><a href="#the-15-puzzle">The 15-Puzzle</a></li>
</ul><h2 id="asic-to-cpu">
<a class="anchor" href="#asic-to-cpu" aria-hidden="true"><span class="octicon octicon-link"></span></a>ASIC to CPU</h2>

<ol>
  <li>
    <p>ASIC (Application Specific Integrated Circuits) are specialized, fast, expensive and very hard to design.</p>
  </li>
  <li>
    <p>CPUs are general purpose, slower, cheaper and easier to program for. A single architecture for multiple purposes.</p>
  </li>
  <li>
    <p>Choosing between ASIC and CPU is a case between <em>efficiency vs flexibility</em></p>
  </li>
</ol>

<h2 id="stark">
<a class="anchor" href="#stark" aria-hidden="true"><span class="octicon octicon-link"></span></a>STARK</h2>

<ol>
  <li>
    <p>STARK is a family of cryptographic proof systems that can be used for privacy and scalability.</p>
  </li>
  <li>
    <p>STARK proves statments, saying that a computation was executed correctly.</p>
  </li>
  <li>
    <p>Examples for provable statements:</p>

    <p>3.1. The 1000th number in the Fibonacci sequence is X.
 3.2. I have 100 signed bank txns that are valid</p>
  </li>
  <li>
    <p>Starkware/Starknet focuses on scalability instead of privacy and the primary focus is to reduce the verification time as much as possible.</p>
  </li>
</ol>

<h2 id="what-is-starknet">
<a class="anchor" href="#what-is-starknet" aria-hidden="true"><span class="octicon octicon-link"></span></a>What is StarkNet</h2>

<p>StarkNet is a permissionless decentralized Validity-rollup (ZK-Rollup). It operates as an L2 network over Ethereum, enabling any dApp to achieve unlimited scale for its computation - without compromising Ethereum’s composability and security (thanks to STARK).</p>

<p>StarkNet contracts and the StarkNet OS are written in Cairo - supporting the deployment and scaling of any use case, whatever the business logic.</p>

<h2 id="wallets-on-starknet">
<a class="anchor" href="#wallets-on-starknet" aria-hidden="true"><span class="octicon octicon-link"></span></a>Wallets on StarkNet</h2>

<p>In StarkNet there is only one type of accounts - smart contract accounts (this is called Account Abstraction), in contrast to Ethereum where there are wallets and smart contracts. Therefore, every wallet on StarkNet is a smart contract and there is no distinction between them and other smart contracts.</p>

<p>Therefore, to create a new wallet, you need to deploy a transaction that publishes your smart contract wallet to the network.</p>

<h2 id="validity-proofs-starknet-zksync">
<a class="anchor" href="#validity-proofs-starknet-zksync" aria-hidden="true"><span class="octicon octicon-link"></span></a>Validity Proofs (StarkNet, zkSync)</h2>

<p>ZK Proofs == Validity Proofs</p>

<p>A novel piece of cryptography lets you collapse quite a bit of computation into a small easily verifiable proof, called zero knowledge proofs.</p>

<p>So, in a network there are a few big computers, doing the heavy lifting of actually doing all the computations, but all the other people in the network with smaller computers have the means to verify the work done by the big computer miners via Zk.</p>

<p>Zk proofs assure you, that some computation was done correctly, without you having to do all the computations.</p>

<p>Basically you have mathematical guarentee that the big computers/miners are working as expected.</p>

<blockquote>
  <p>And, the beautiful thing about this is that these proofs can be verified by Ethereum too.</p>
</blockquote>

<h2 id="proofs">
<a class="anchor" href="#proofs" aria-hidden="true"><span class="octicon octicon-link"></span></a>Proofs</h2>

<p>Think of proofs as a new cryptographic primitive where a prover can present his <em>proof</em> for having spent certain resources for doing certain amount of computations.</p>

<p>Basic Assumption for proofs, and for validity proofs to be considered legitimate is that:</p>

<p><em>Time(proof verification) &lt; Time(underlying program execution)</em></p>

<p>Ethereum can natively understand the zk-proofs generated by the prover.</p>

<p>There is no middle man between Starknet and Ethereum.</p>

<h2 id="the-case-of-middle-men">
<a class="anchor" href="#the-case-of-middle-men" aria-hidden="true"><span class="octicon octicon-link"></span></a>The case of Middle Men</h2>

<p><em>How do you get to use BTC on the ETH chain ?</em></p>

<p>You give your BTC to <strong>BitGo</strong> and they give you equivalent ERC20 tokens of WBTC (minus some fee).</p>

<p>In this process, there is a huge human component involved. Humans have to do the translation between chains.</p>

<p>Most L1’s and bridges work this way.</p>

<p>Yes, we do have certain incentives for those humans to not cheat. However, with this primitive (proofs) we do not need humans whatsoever.</p>

<h2 id="awesomeness-of-zkp-recursions">
<a class="anchor" href="#awesomeness-of-zkp-recursions" aria-hidden="true"><span class="octicon octicon-link"></span></a>Awesomeness of ZKP (Recursions)</h2>

<p>Size of proofs increase logarithmically with the number of computations.</p>

<h3 id="recursion-a-thought-experiment">
<a class="anchor" href="#recursion-a-thought-experiment" aria-hidden="true"><span class="octicon octicon-link"></span></a>Recursion: A Thought Experiment</h3>

<p>Soon enough, what you’ll be able to do is start a StarkNet instance, do some computations and send the proof to another StarkNet instance which is 1 layer below it, to verify the proof.</p>

<p>That lower instance again does it’s own computations and creates a new proof from the proof it recieved + it’s own computations and then sends this new proof one layer down.</p>

<p>This keeps on happening until eventually the proofs reach the underlying L1 with a single proof of a fuck-ton of computations.</p>

<blockquote>
  <p>Ethereum verifying the proofs sent over has nothing to do with PoW. The verification is done banking on the EVM’s ability to process and run opcodes. So, if Ethereum uses PoW or PoS or anything else going into the future, as long as EVM can process opcodes, it can verify zk-proofs</p>
</blockquote>

<h3 id="calculations">
<a class="anchor" href="#calculations" aria-hidden="true"><span class="octicon octicon-link"></span></a>Calculations</h3>

<p>StarkNet so good at calculations, you could run entire game engines on top of it. Case in point is the recursion that we just discussed. Kinda makes on-chain  computation infinitely scalable.</p>

<p>Do not assume privacy from StarkNet. Because the txn block you send would be visible in clear. Only advantage here is that you do not need to repeat all computations to verify all computations.</p>

<h2 id="stark-vs-snark">
<a class="anchor" href="#stark-vs-snark" aria-hidden="true"><span class="octicon octicon-link"></span></a>Stark vs Snark</h2>

<p>Stark prover is way more efficient (faster) than Snark. Snark beats Stark in other areas, but proving time is the criterion with which StartNet moves ahead.</p>

<h2 id="cairo">
<a class="anchor" href="#cairo" aria-hidden="true"><span class="octicon octicon-link"></span></a>Cairo</h2>

<p>Cairo is a turing-complete language (a language that has overcome the halting problem) that developer can use to leverage the power of STARKs.</p>

<p>Cairo does not have any circuits associated with it.</p>

<p>The Cairo CPU is quite different than your regular x86 in the sense that your x86 is very good at logical operations but bad at division, the case is inverted in case of Cairo CPU.</p>

<p>Cairo helps you program non-determinism into your program (I do not understand what that means. Yet.)</p>

<h3 id="from-the-documentation">
<a class="anchor" href="#from-the-documentation" aria-hidden="true"><span class="octicon octicon-link"></span></a>From the documentation</h3>

<ol>
  <li>
    <p>Cairo is not a high-level programming language but a low-level programming language with powerful syntactical sugar. Cairo is powerful enough to write almost anything that can run on the Cairo VM.</p>
  </li>
  <li>
    <p><em>Recursion instead of loops</em></p>
  </li>
</ol>

<p>Cairo memory is immutable and once something is written to a slot, it cannot be changed in the future and hence we try and use recursions instead of loops.</p>

<p>Loops are possible, but very complicated to implement in Cairo (this might change in Cairo v1.0)</p>

<ol>
  <li><em>Assert Statements</em></li>
</ol>

<p>In Cairo, assert statements such as</p>
<pre><code class="language-cairo">assert [ptr] = 0;
</code></pre>

<p>will assert that the value of memory cell at address <code class="language-plaintext highlighter-rouge">ptr</code> is indeed 0 or not <strong>iff</strong> the value of the memory cell at address <code class="language-plaintext highlighter-rouge">ptr</code> was already 0. Otherwise, Cairo will set the value of [ptr] to 0 and then assert it to be equal to 0, making the assert to pass.</p>

<p>Also you can’t re-set the value of [ptr] if you’ve already set it before, this behaviour is again a testimony to the fact that the Cairo memory is immutable.</p>

<ol>
  <li>Writing a <em>main()</em> function</li>
</ol>

<p>Consider the following function</p>

<pre><code class="language-cairo">
%builtins output

from starkware.cairo.common.serialize import serialize_word

func main{output_ptr: felt*}() {
    serialize_word(1234);
    serialize_word(4321);
    return ();
}

</code></pre>

<p>The <code class="language-plaintext highlighter-rouge">main()</code> function is the starting point of all Cairo prorams.</p>

<p>The <code class="language-plaintext highlighter-rouge">%builtin outputs</code> helps Cairo communicate with the external world, think <code class="language-plaintext highlighter-rouge">cout</code> from C++. The communication with the builtin is done by reading/writing values to the memory. The output builtin is quite simple: Declaring it using %builtins turns the signature of main() to main{output_ptr: felt*}().</p>

<p><code class="language-plaintext highlighter-rouge">{}</code> represents implicit arguments.</p>

<p>The argument (from the main function) points to the beginning of the memory segment to which the program output should be written. The program then returns a pointer to the memory that marks the end of the output. The convention we use in Cairo, is that the end of a memory segment always points to the <strong>memory cell after the last written cell.</strong></p>

<p>The function <code class="language-plaintext highlighter-rouge">serialize_word</code> takes one implicit argument (and thus returns one implicit argument) and takes one explicit argument (the one that we need to write)</p>

<p><code class="language-plaintext highlighter-rouge">serialize_output(x)</code> writes x to the memory cell pointed by <code class="language-plaintext highlighter-rouge">output_ptr</code> (that is, <code class="language-plaintext highlighter-rouge">[output_ptr]</code>) and returns <code class="language-plaintext highlighter-rouge">output_ptr + 1</code>. Now the implicit argument mechanism kicks in: in the first call to serialize_word() the Cairo compiler passes the value of output_ptr as the implicit argument. In the second call it uses the value returned by the first call.</p>

<p>The import statement is well…. an import statement. You could also have done <code class="language-plaintext highlighter-rouge">... import serialize_word as foo</code> to use the name <code class="language-plaintext highlighter-rouge">foo</code> for <code class="language-plaintext highlighter-rouge">serialize_word</code>.</p>

<ol>
  <li>Field Elements (felt)</li>
</ol>

<p>What we mean by a felt in Cairo is an integer in the range -P/2 &lt; x &lt; P/2 where P is a very large (prime) number (currently it is a 252-bit number, which is a number with 76 decimal digits). All calculations (multiplication, addition, subtraction) are done as modulo P.</p>

<p>The important distinction here is in division. Do not think of division in felts as normal integer division. As long as the numerator is perfectly divisible by the denominator, you will get the expected output, but for something like 7/3 instead of 2 (or 2.333…) you will get an arbitrarily large number.</p>

<p>This is because, for division to be successful in Cairo, it must satisfy the equation</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>(x/y) * y = x

</code></pre></div></div>

<p>So, (6/2) * 2 is indeed 6, but (7/2)*2 != 7, right?</p>

<p>But you know what is correct value of <code class="language-plaintext highlighter-rouge">y</code> in the second case? See this:</p>

<p>(P + 7 / 2) * 2 = P + 7 and (P + 7) modulo P is 7. Therefore, the answer to this division of 7/3 is (P+7)/2</p>

<h2 id="first-lines-of-cairo">
<a class="anchor" href="#first-lines-of-cairo" aria-hidden="true"><span class="octicon octicon-link"></span></a>First lines of Cairo</h2>

<pre><code class="language-cairo"># fun with cairo

func sqr(a) -&gt; (a):
    return (a = a * a)
end

func add_num_square(x, y) -&gt; (x):
    let a = x + y
    let (z) = sqr(a = a)
    return (x = z)
end

func main():
    let (x) = add_num_square(x = 1, y = 3)
    assert x = 16
    return ()
end

</code></pre>

<h3 id="sum-of-all-elements-of-an-array">
<a class="anchor" href="#sum-of-all-elements-of-an-array" aria-hidden="true"><span class="octicon octicon-link"></span></a>Sum of all elements of an array</h3>

<pre><code class="language-cairo">
%builtins output

from starkware.cairo.common.serialize import serialize_word
from starkware.cairo.common.alloc import alloc

func arr_sum(arr: felt*, size) -&gt; felt {
    if(size == 0) {
        return 0;
    }
    
    let sum_of_rest = arr_sum(arr = arr + 1, size = size - 1);
    return arr[0] + sum_of_rest;
}

func main{output_ptr: felt*}() {
    const SIZE_ARRAY = 3;
    
    // allocate an array
    let (ptr) = alloc();
    
    assert[ptr] = 33;
    assert[ptr + 1] = 44;
    assert[ptr + 2] = 69;
    
    let sum_of_array = arr_sum(arr = ptr, size = SIZE_ARRAY);
    serialize_word(sum_of_array);
    
    return();
}

</code></pre>

<h3 id="product-of-all-even-entries-of-the-array">
<a class="anchor" href="#product-of-all-even-entries-of-the-array" aria-hidden="true"><span class="octicon octicon-link"></span></a>Product of all even entries of the array</h3>

<pre><code class="language-cairo">
%builtins output

from starkware.cairo.common.serialize import serialize_word as print
from starkware.cairo.common.alloc import alloc

func arr_sum(arr: felt*, size) -&gt; felt {
    if(size == 0) {
        return 0;
    }
    
    let sum_of_others = arr_sum(arr = arr + 1, size = size - 1);
    return arr[0] + sum_of_others;
}

func arr_product(arr: felt*, size) -&gt; felt {
    if(size == 0) {
        return 1;
    }
    
    // This is assuming an even length of array
    let prod_of_others = arr_product(arr = arr + 2, size = size - 2);
    return arr[0] * prod_of_others;
}

func main{output_ptr: felt*}() {

    const ARR_SIZE = 4;
    // Initializing space for an array
    let (ptr) = alloc();
    // Putting out the initial values in the array
    assert [ptr] = 40;
    assert [ptr + 1] = 3;
    assert [ptr + 2] = 2;
    assert [ptr + 3] = 1;
    
    // let sum_of_array = arr_sum(ptr, ARR_SIZE);
    // print(sum_of_array);
    
    let product_of_even_array = arr_product(arr = ptr, size = ARR_SIZE);
    print(product_of_even_array);
    
    return();
}

</code></pre>

<h2 id="the-15-puzzle">
<a class="anchor" href="#the-15-puzzle" aria-hidden="true"><span class="octicon octicon-link"></span></a>The 15-Puzzle</h2>

<p>%builtins output</p>

<p>from starkware.cairo.common.serialize import serialize_word as print</p>

<p>struct Location {
    row: felt,
    col: felt,
}</p>

<p>// Location*
// The expression Location* instructs Cairo to interpret <code class="language-plaintext highlighter-rouge">loc</code> as the address of a <code class="language-plaintext highlighter-rouge">Location</code> instance.
// This means that it will expect that the value of the memory at address <code class="language-plaintext highlighter-rouge">loc</code> is the row of the location, and
// the value at address <code class="language-plaintext highlighter-rouge">loc + 1</code> is the column. loc.row and loc.col is just syntatic sugar</p>

<p>// Tempvar
// The scope of a temporary variable is limited. Using it is delicate since a temporary variable maybe revoked due to jumps/function calls etc.</p>

<p>// &lt; operator
// In cairo, the less than operation is a complicated operation and so Cairo has a builtin called range-check that allows comparing values</p>

<p>// return()
// In Cairo the return statment is not implicit even if the function does not return anything</p>

<p>func verify_adjacent_locations(loc0: Location<em>, loc1: Location</em>) {
    alloc_locals;
    local row_diff = loc0.row - loc1.row;
    local col_diff = loc0.col - loc1.col;</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>if(row_diff == 0) {
    assert col_diff * col_diff = 1;
    return ();
} else {
    assert row_diff * row_diff = 1;
    assert col_diff = 0;
    return();
} }
</code></pre></div></div>

<p>// local variables are much more less restricted than tempvar and can be accessed till the end of a function without exception
// alloc_locals allocates memory required for the local variables of the function. Usually, this should be the first statement in a function which uses local variables.</p>

<p>func verify_valid_location(loc: Location*) {
    // Check that row is in range 0-3
    tempavar row = loc.row;
    assert row * (row - 1) * (row - 2) * (row - 3) = 0;</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// Check that column is in range 0-3
tempvar col = loc.col;
assert col * (col - 1) * (col - 2) * (col - 3) = 0;

return (); }
</code></pre></div></div>

<p>// A reference is defined using a <code class="language-plaintext highlighter-rouge">let</code> statement.
// So, let x = y<em>y</em>y</p>

<p>func main{output_ptr: felt*}(){
    print(214);
    return();
}</p>

  </div><!-- from https://github.com/utterance/utterances -->
<script src="https://utteranc.es/client.js"
        repo="saxenism/saxenism-expressions"
        issue-term="title"
        label="blogpost-comment"
        theme="github-dark"
        crossorigin="anonymous"
        async>
</script><div id="disqus_thread"></div>
  <script>
    var disqus_config = function () {
      this.page.url = 'https://saxenism.com/web3/cairo/starknet/beginner/zero-knowledge/2022/09/07/Cairo-101.html';
      this.page.identifier = 'https://saxenism.com/web3/cairo/starknet/beginner/zero-knowledge/2022/09/07/Cairo-101.html';
    };

    (function() {
      var d = document, s = d.createElement('script');

      s.src = 'https://.disqus.com/embed.js';

      s.setAttribute('data-timestamp', +new Date());
      (d.head || d.body).appendChild(s);
    })();
  </script>
  <noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript" rel="nofollow">comments powered by Disqus.</a></noscript><a class="u-url" href="/web3/cairo/starknet/beginner/zero-knowledge/2022/09/07/Cairo-101.html" hidden></a>
</article>

      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/"></data>

  <div class="wrapper">

    <div class="footer-col-wrapper">
      <div class="footer-col">
        <p class="feed-subscribe">
          <a href="/feed.xml">
            <svg class="svg-icon orange">
              <use xlink:href="/assets/minima-social-icons.svg#rss"></use>
            </svg><span>Subscribe</span>
          </a>
        </p>
      </div>
      <div class="footer-col">
        <p>Personal website of Rahul Saxena, containing his thoughts about web3, EVM and a decentralised world.</p>
      </div>
    </div>

    <div class="social-links"><ul class="social-media-list"><li>
  <a rel="me" href="https://feedrabbit.com/subscriptions/new?url=https%3A%2F%2Fsaxenism.com%2F" target="_blank" title="rss">
    <svg class="svg-icon grey">
      <use xlink:href="/assets/minima-social-icons.svg#rss"></use>
    </svg>
  </a>
</li>
<li>
  <a rel="me" href="https://github.com/saxenism" target="_blank" title="github">
    <svg class="svg-icon grey">
      <use xlink:href="/assets/minima-social-icons.svg#github"></use>
    </svg>
  </a>
</li>
<li>
  <a rel="me" href="https://twitter.com/saxenism" target="_blank" title="twitter">
    <svg class="svg-icon grey">
      <use xlink:href="/assets/minima-social-icons.svg#twitter"></use>
    </svg>
  </a>
</li>
<li>
  <a rel="me" href="https://www.linkedin.com/in/saxena-rahul/" target="_blank" title="linkedin">
    <svg class="svg-icon grey">
      <use xlink:href="/assets/minima-social-icons.svg#linkedin"></use>
    </svg>
  </a>
</li>
</ul>
</div>

  </div>

</footer>
</body>

</html>
